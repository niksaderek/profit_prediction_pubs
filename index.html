<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Profit Prediction System</title>
    
    <!-- Favicon - matches brand icon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><defs><linearGradient id='grad' x1='0%' y1='0%' x2='100%' y2='100%'><stop offset='0%' style='stop-color:%233b82f6;stop-opacity:1' /><stop offset='100%' style='stop-color:%238b5cf6;stop-opacity:1' /></linearGradient></defs><rect width='32' height='32' rx='8' fill='url(%23grad)'/><path d='M8 20l4-4 4 4 8-8' stroke='white' stroke-width='2' fill='none' stroke-linecap='round' stroke-linejoin='round'/><circle cx='8' cy='20' r='1' fill='white'/><circle cx='12' cy='16' r='1' fill='white'/><circle cx='16' cy='20' r='1' fill='white'/><circle cx='24' cy='12' r='1' fill='white'/></svg>">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- Papa Parse for CSV handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f8fafc;
            color: #334155;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }
        
        .header {
            background: white;
            border-bottom: 1px solid #e2e8f0;
            padding: 20px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .brand-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
        }
        
        .brand-text {
            font-size: 20px;
            font-weight: 600;
            color: #1e293b;
        }
        
        .nav-actions {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        .btn-ghost {
            background: none;
            border: 1px solid #e2e8f0;
            color: #64748b;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-ghost:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }
        
        .btn-ghost.debug-active {
            background: #1e293b;
            color: #e2e8f0;
            border-color: #334155;
        }
        
        .btn-ghost.debug-active:hover {
            background: #334155;
            border-color: #475569;
        }
        
        .main-content {
            padding: 32px 0;
        }
        
        .page-header {
            text-align: center;
            margin-bottom: 48px;
        }
        
        .page-title {
            font-size: 32px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 12px;
        }
        
        .page-subtitle {
            font-size: 18px;
            color: #64748b;
            font-weight: 400;
        }
        
        .debug-panel {
            background: #1e293b;
            color: #e2e8f0;
            border-radius: 8px;
            margin-bottom: 24px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .debug-panel.collapsed {
            max-height: 0;
            margin-bottom: 0;
            opacity: 0;
            transform: translateY(-10px);
            padding: 0;
        }
        
        .debug-panel.expanded {
            padding: 16px;
            max-height: 500px;
            opacity: 1;
            transform: translateY(0);
        }
        
        .debug-title {
            color: #60a5fa;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .two-column-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 32px;
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .card {
            background: white;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .card:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .card-header {
            padding: 24px 24px 0 24px;
            border-bottom: none;
        }
        
        .card-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 8px;
        }
        
        .card-subtitle {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 24px;
        }
        
        .card-body {
            padding: 0 24px 24px 24px;
        }
        
        .form-group {
            margin-bottom: 24px;
        }
        
        .form-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
        }
        
        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: white;
        }
        
        .form-control:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .input-group {
            position: relative;
        }
        
        .input-prefix {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #6b7280;
            font-size: 14px;
            font-weight: 500;
        }
        
        .input-group .form-control {
            padding-left: 32px;
        }
        
        .form-text {
            font-size: 13px;
            color: #6b7280;
            margin-top: 4px;
        }
        
        .required {
            color: #ef4444;
        }
        
        .verticals-grid {
            display: grid;
            gap: 12px;
        }
        
        .vertical-option {
            position: relative;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
        }
        
        .vertical-option:hover {
            border-color: #d1d5db;
            background: #f9fafb;
        }
        
        .vertical-option.selected {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .vertical-option input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
        }
        
        .vertical-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .vertical-name {
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
        }
        
        .vertical-badge {
            font-size: 11px;
            font-weight: 500;
            padding: 2px 8px;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
        
        .badge-success {
            background: #dcfce7;
            color: #166534;
        }
        
        .badge-primary {
            background: #dbeafe;
            color: #1d4ed8;
        }
        
        .badge-info {
            background: #e0f2fe;
            color: #0369a1;
        }
        
        .badge-warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .badge-secondary {
            background: #f1f5f9;
            color: #475569;
        }
        
        .vertical-stats {
            font-size: 12px;
            color: #6b7280;
        }
        
        .btn-primary {
            width: 100%;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            border: none;
            color: white;
            padding: 14px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 24px;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: white;
            border: 1px solid #d1d5db;
            color: #374151;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-secondary:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }
        
        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 24px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #3b82f6;
            background: #f8fafc;
        }
        
        .upload-area.dragover {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .upload-icon {
            font-size: 24px;
            color: #6b7280;
            margin-bottom: 8px;
        }
        
        .upload-text {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .upload-subtext {
            font-size: 12px;
            color: #9ca3af;
        }
        
        .results-container {
            margin-top: 32px;
            display: none;
        }
        
        .result-card {
            background: white;
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .result-header {
            text-align: center;
            margin-bottom: 32px;
        }
        
        .profit-display {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .profit-positive {
            color: #059669;
        }
        
        .profit-negative {
            color: #dc2626;
        }
        
        .profit-label {
            font-size: 16px;
            color: #6b7280;
            margin-bottom: 16px;
        }
        
        .confidence-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: white;
            color: #0369a1;
            padding: 4px 12px;
            border-radius: 16px;
            border: 1px solid #e5e7eb;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }
        
        .metric-card {
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            padding: 16px;
            text-align: center;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .metric-card:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .metric-label {
            font-size: 12px;
            color: #64748b;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
        
        .metric-subtitle {
            font-size: 11px;
            color: #94a3b8;
            margin-top: 2px;
        }
        
        .insights-section {
            border-top: 1px solid #e2e8f0;
            padding-top: 24px;
        }
        
        .insights-title {
            font-size: 16px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 16px;
        }
        
        .insight-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            margin-bottom: 8px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .insight-item:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .insight-icon {
            font-size: 16px;
            line-height: 1;
            margin-top: 2px;
        }
        
        .insight-content {
            flex: 1;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .insight-category {
            font-weight: 600;
            color: #374151;
        }
        
        .actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 24px;
        }
        
        .alert {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 24px;
            border-left: 4px solid;
            border-right: 1px solid #e5e7eb;
            border-top: 1px solid #e5e7eb;
            border-bottom: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .alert-info {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1e40af;
        }
        
        .alert-warning {
            background: #fffbeb;
            border-color: #f59e0b;
            color: #92400e;
        }
        
        .alert-danger {
            background: #fef2f2;
            border-color: #ef4444;
            color: #dc2626;
        }
        
        .alert-success {
            background: #f0fdf4;
            border-color: #22c55e;
            color: #16a34a;
        }
        
        .model-status {
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
            transition: all 0.2s ease;
        }
        
        .status-item:hover {
            background: #f8fafc;
            border-radius: 4px;
            padding-left: 8px;
            padding-right: 8px;
        }
        
        .status-item:last-child {
            border-bottom: none;
        }
        
        .status-label {
            font-size: 13px;
            color: #64748b;
            font-weight: 500;
        }
        
        .status-value {
            font-size: 13px;
            color: #1e293b;
            font-weight: 600;
        }
        
        .hidden {
            display: none;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .pulse {
            animation: pulse 1s ease-in-out;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .analytics-section {
            margin-top: 24px;
        }
        
        /* How It Works Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .modal-overlay.show {
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
        }
        
        .modal-content {
            background: white;
            border-radius: 16px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 32px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay.show .modal-content {
            transform: translateY(0);
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #64748b;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: #f1f5f9;
            color: #1e293b;
        }
        
        .modal-section {
            margin-bottom: 32px;
        }
        
        .modal-section:last-child {
            margin-bottom: 0;
        }
        
        .modal-section-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .modal-section-content {
            color: #475569;
            line-height: 1.6;
        }
        
        .modal-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .modal-list li {
            padding: 8px 0;
            padding-left: 24px;
            position: relative;
        }
        
        .modal-list li:before {
            content: "•";
            color: #3b82f6;
            font-weight: bold;
            position: absolute;
            left: 8px;
        }
        
        .modal-highlight {
            background: #f0f9ff;
            border: 1px solid #bfdbfe;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        
        .modal-highlight-title {
            font-weight: 600;
            color: #1e40af;
            margin-bottom: 8px;
        }
        
        .modal-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin: 16px 0;
        }
        
        .modal-stat {
            text-align: center;
            padding: 16px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .modal-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 4px;
        }
        
        .modal-stat-label {
            font-size: 12px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.025em;
            font-weight: 500;
        }
        
        /* Temporal Weighting Switch */
        .temporal-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        
        .temporal-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .temporal-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: .3s;
            border-radius: 24px;
        }
        
        .temporal-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        input:checked + .temporal-slider {
            background-color: #059669;
        }
        
        input:checked + .temporal-slider:before {
            transform: translateX(20px);
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }
            
            .two-column-layout {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .page-title {
                font-size: 24px;
            }
            
            .page-subtitle {
                font-size: 16px;
            }
            
            .profit-display {
                font-size: 36px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr 1fr;
                gap: 12px;
            }
            
            .actions {
                flex-direction: column;
            }
            
            .header-content {
                flex-direction: column;
                gap: 16px;
            }
            
            .nav-actions {
                width: 100%;
                justify-content: center;
            }
            
            /* MAE and Confidence Interval responsive */
            .mae-confidence-grid {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }
            
            .mae-confidence-grid .metric-card {
                padding: 12px !important;
            }
            
            .mae-confidence-grid .metric-value {
                font-size: 20px !important;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="brand">
                    <div class="brand-icon">
                        <i class="fas fa-chart-line"></i>
                    </div>
                    <div class="brand-text">Daily Profit Predictor</div>
                </div>
                <div class="nav-actions">
                    <button class="btn-ghost" onclick="showHowItWorks()" id="how-it-works-btn">
                        <i class="fas fa-info-circle me-1"></i> How it Works
                    </button>
                    <button class="btn-ghost" onclick="toggleDebugPanel()" id="debug-toggle">
                        <i class="fas fa-bug me-1"></i> Debug
                    </button>
                    <button class="btn-ghost" onclick="resetForm()">
                        <i class="fas fa-refresh me-1"></i> Reset Form
                    </button>
                    <button class="btn-ghost" onclick="clearAllData()" id="clear-data-btn" style="display: none;">
                        <i class="fas fa-trash me-1"></i> Clear Data
                    </button>
                    <button class="btn-ghost" onclick="window.print()">
                        <i class="fas fa-download me-1"></i> Export
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            <!-- Page Header -->
            <div class="page-header">
                <h1 class="page-title">Daily Profit Prediction System</h1>
                <p class="page-subtitle">Affiliate publishers net profit prediction</p>
            </div>
            
            <!-- Debug Panel -->
            <div class="debug-panel collapsed" id="debug-panel">
                <div class="debug-title">🔍 Debug Information</div>
                <div id="debug-content">Ready to debug predictions...</div>
            </div>
            
            <!-- How It Works Modal -->
            <div class="modal-overlay" id="how-it-works-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2 class="modal-title">How the Prediction System Works</h2>
                        <button class="modal-close" onclick="hideHowItWorks()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="modal-section">
                        <h3 class="modal-section-title">
                            <i class="fas fa-brain" style="color: #3b82f6;"></i>
                            Daily Profit Prediction Model
                        </h3>
                        <div class="modal-section-content">
                            <p>The system uses a margin-based regression model that analyzes historical patterns to predict your daily profit margin. The model considers:</p>
                            <ul class="modal-list">
                                <li><strong>Vertical Performance:</strong> Historical margin rates for each vertical (Medicare, ACA, etc.)</li>
                                <li><strong>Publisher Count Effects:</strong> How the number of affiliate publishers impacts margin</li>
                                <li><strong>Day-of-Week Patterns:</strong> Performance variations across business days</li>
                                <li><strong>Temporal Weighting:</strong> Recent data weighted more heavily than older data</li>
                            </ul>
                            <div class="modal-highlight">
                                <div class="modal-highlight-title">Algorithm:</div>
                                Multi-factor linear regression with temporal weighting, vertical margins, and publisher count effects
                            </div>
                            <div class="modal-highlight" style="background: #f0fdf4; border-color: #22c55e;">
                                <div class="modal-highlight-title" style="color: #166534;">Temporal Weighting:</div>
                                Recent data receives exponentially higher weight in calculations. Default decay rate: 2% per day (data from 35 days ago has ~50% weight, 90 days ago has ~17% weight). This ensures predictions adapt quickly to changing market conditions.
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <h3 class="modal-section-title">
                            <i class="fas fa-trophy" style="color: #f59e0b;"></i>
                            Publisher Performance Scoring (0-100 Scale)
                        </h3>
                        <div class="modal-section-content">
                            <div class="modal-stats-grid">
                                <div class="modal-stat">
                                    <div class="modal-stat-value" style="color: #059669;">40%</div>
                                    <div class="modal-stat-label">Daily Profit</div>
                                </div>
                                <div class="modal-stat">
                                    <div class="modal-stat-value" style="color: #0ea5e9;">25%</div>
                                    <div class="modal-stat-label">Margin Rate</div>
                                </div>
                                <div class="modal-stat">
                                    <div class="modal-stat-value" style="color: #8b5cf6;">20%</div>
                                    <div class="modal-stat-label">Call Performance</div>
                                </div>
                                <div class="modal-stat">
                                    <div class="modal-stat-value" style="color: #f59e0b;">15%</div>
                                    <div class="modal-stat-label">Consistency</div>
                                </div>
                            </div>
                            <ul class="modal-list">
                                <li><strong>Daily Profit (40%):</strong> Average daily profit contribution</li>
                                <li><strong>Margin Rate (25%):</strong> Profitability percentage</li>
                                <li><strong>Call Performance (20%):</strong> Volume, connect & conversion rates</li>
                                <li><strong>Consistency (15%):</strong> Active days and reliability</li>
                            </ul>
                            <div class="modal-highlight">
                                <div class="modal-highlight-title">Formula:</div>
                                Score = (Daily Profit/100 × 40) + (Margin Rate × 25) + (Call Performance × 20) + (Active Days × 15)
                                <br><br>
                                <strong>Note:</strong> Publishers without call volume data receive consistency-based scoring for the call performance component.
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <h3 class="modal-section-title">
                            <i class="fas fa-database" style="color: #10b981;"></i>
                            Training Data Processing
                        </h3>
                        <div class="modal-section-content">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin: 16px 0;">
                                <div>
                                    <h4 style="font-weight: 600; margin-bottom: 12px; color: #1e293b;">Data Filtering</h4>
                                    <ul class="modal-list">
                                        <li>Weekend records excluded</li>
                                        <li>Null margin values removed</li>
                                        <li>Missing revenue/profit data filtered</li>
                                        <li>Business days only (Mon-Fri)</li>
                                    </ul>
                                </div>
                                <div>
                                    <h4 style="font-weight: 600; margin-bottom: 12px; color: #1e293b;">Aggregation Method</h4>
                                    <ul class="modal-list">
                                        <li>Daily totals by date</li>
                                        <li>Publisher performance metrics</li>
                                        <li>Vertical-specific margins</li>
                                        <li>Publisher count effects</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="modal-section">
                        <h3 class="modal-section-title">
                            <i class="fas fa-chart-line" style="color: #dc2626;"></i>
                            Model Accuracy & Validation
                        </h3>
                        <div class="modal-section-content">
                            <div class="modal-stats-grid">
                                <div class="modal-stat">
                                    <div class="modal-stat-value" style="color: #dc2626;">87.3%</div>
                                    <div class="modal-stat-label">Prediction Accuracy</div>
                                </div>
                                <div class="modal-stat">
                                    <div class="modal-stat-value" style="color: #059669;">402</div>
                                    <div class="modal-stat-label">Training Records</div>
                                </div>
                            </div>
                            <p><strong>Based on:</strong> Historical back-testing across 402 individual training records</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin: 16px 0;">
                                <div>
                                    <h4 style="font-weight: 600; margin-bottom: 12px; color: #1e293b;">Validation Method</h4>
                                    <ul class="modal-list">
                                        <li>Cross-validation testing</li>
                                        <li>Error rate analysis</li>
                                        <li>Outlier detection & removal</li>
                                        <li>Continuous model refinement</li>
                                    </ul>
                                </div>
                                <div>
                                    <div class="modal-highlight">
                                        <div class="modal-highlight-title">Model Performance</div>
                                        The system maintains high accuracy by continuously validating predictions against actual results and adjusting coefficients based on new training data.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Model Retrain Success Modal -->
            <div class="modal-overlay" id="retrain-success-modal">
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2 class="modal-title" style="color: #059669; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-check-circle"></i>
                            Model Updated Successfully!
                        </h2>
                        <button class="modal-close" onclick="hideRetrainSuccess()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="modal-section">
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="font-size: 48px; color: #059669; margin-bottom: 16px;">
                                <i class="fas fa-brain"></i>
                            </div>
                            <p style="font-size: 16px; color: #374151; margin-bottom: 8px;">Your prediction model has been successfully retrained with the new data.</p>
                            <p style="font-size: 14px; color: #6b7280;">The system is now ready to provide more accurate predictions based on your latest business data.</p>
                        </div>
                        
                        <div class="modal-stats-grid" style="margin: 24px 0;">
                            <div class="modal-stat">
                                <div class="modal-stat-value" style="color: #1e293b;" id="retrain-records">-</div>
                                <div class="modal-stat-label">Training Records</div>
                            </div>
                            <div class="modal-stat">
                                <div class="modal-stat-value" style="color: #059669;" id="retrain-accuracy">-</div>
                                <div class="modal-stat-label">Model Accuracy</div>
                            </div>
                            <div class="modal-stat">
                                <div class="modal-stat-value" style="color: #0ea5e9;" id="retrain-revenue">-</div>
                                <div class="modal-stat-label">Avg Daily Revenue</div>
                            </div>
                            <div class="modal-stat">
                                <div class="modal-stat-value" style="color: #8b5cf6;" id="retrain-profit">-</div>
                                <div class="modal-stat-label">Avg Daily Profit</div>
                            </div>
                        </div>
                        
                        <div style="background: #f0f9ff; border: 1px solid #bfdbfe; border-radius: 8px; padding: 16px; margin: 16px 0;">
                            <div style="font-weight: 600; color: #1e40af; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                <i class="fas fa-lightbulb"></i>
                                What's Next?
                            </div>
                            <p style="font-size: 14px; color: #1e40af; margin: 0;">Try making a new prediction with your updated model to see improved accuracy and insights.</p>
                        </div>
                        
                        <div style="text-align: center; margin-top: 24px;">
                            <button class="btn-primary" onclick="hideRetrainSuccess()" style="width: auto; padding: 12px 24px; margin: 0;">
                                <i class="fas fa-rocket me-1"></i>
                                Start Predicting
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Alert Container -->
            <div id="alert-container"></div>
            
            <!-- Two Column Layout -->
            <div class="two-column-layout">
                <!-- Left Column - Prediction Form -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Daily Prediction</h2>
                        <p class="card-subtitle">ML model predicts your margin automatically based on training data</p>
                    </div>
                    <div class="card-body">
                        <form id="prediction-form">
                            <!-- Number of Affiliate Publishers -->
                            <div class="form-group">
                                <label for="num_media_buyers" class="form-label">
                                    Number of Affiliate Publishers <span class="required">*</span>
                                </label>
                                <div class="input-group">
                                    <span class="input-prefix">#</span>
                                    <input 
                                        type="number" 
                                        id="num_media_buyers" 
                                        class="form-control" 
                                        min="1" 
                                        value="5" 
                                        required
                                        onchange="updateDebugInfo(); checkPublisherWarning()"
                                        oninput="updateDebugInfo(); checkPublisherWarning()"
                                    >
                                </div>
                                <div class="form-text">How many affiliate publishers will be generating revenue today?</div>
                            </div>
                            
                            <!-- Expected Daily Revenue -->
                            <div class="form-group">
                                <label for="target_revenue" class="form-label">
                                    Total Daily Revenue <span class="required">*</span>
                                </label>
                                <div class="input-group">
                                    <span class="input-prefix">$</span>
                                    <input 
                                        type="number" 
                                        id="target_revenue" 
                                        class="form-control" 
                                        min="1000" 
                                        step="500" 
                                        value="25000" 
                                        required
                                        onchange="updateDebugInfo()"
                                        oninput="updateDebugInfo()"
                                    >
                                </div>
                                <div class="form-text">Total revenue that will be generated today (margin will be calculated automatically)</div>
                            </div>
                            
                            <!-- Verticals Selection -->
                            <div class="form-group">
                                <label class="form-label">
                                    Active Verticals <span class="required">*</span>
                                </label>
                                <div class="form-text" style="margin-bottom: 12px;">
                                    Select which verticals will be running today
                                </div>
                                
                                <div class="verticals-grid">
                                    <label class="vertical-option" for="vertical_medicare_en">
                                        <input type="checkbox" value="MEDICARE ENGLISH" id="vertical_medicare_en" onchange="handleVerticalChange(event)">
                                        <div class="vertical-header">
                                            <span class="vertical-name">Medicare English</span>
                                            <span class="vertical-badge badge-success">Top Performer</span>
                                        </div>
                                        <div class="vertical-stats">Historical Margin: 21.3% • Top performer</div>
                                    </label>
                                    
                                    <label class="vertical-option" for="vertical_final_expense">
                                        <input type="checkbox" value="FINAL EXPENSE ENGLISH" id="vertical_final_expense" onchange="handleVerticalChange(event)">
                                        <div class="vertical-header">
                                            <span class="vertical-name">Final Expense English</span>
                                            <span class="vertical-badge badge-primary">Solid Performer</span>
                                        </div>
                                        <div class="vertical-stats">Historical Margin: 21.6% • Solid performer</div>
                                    </label>
                                    
                                    <label class="vertical-option" for="vertical_aca">
                                        <input type="checkbox" value="ACA ENGLISH" id="vertical_aca" onchange="handleVerticalChange(event)">
                                        <div class="vertical-header">
                                            <span class="vertical-name">ACA English</span>
                                            <span class="vertical-badge badge-info">Seasonal</span>
                                        </div>
                                        <div class="vertical-stats">Historical Margin: 24.4% • Seasonal strength</div>
                                    </label>
                                    
                                    <label class="vertical-option" for="vertical_medicare_es">
                                        <input type="checkbox" value="MEDICARE SPANISH" id="vertical_medicare_es" onchange="handleVerticalChange(event)">
                                        <div class="vertical-header">
                                            <span class="vertical-name">Medicare Spanish</span>
                                            <span class="vertical-badge badge-warning">Growing</span>
                                        </div>
                                        <div class="vertical-stats">Historical Margin: 24.5% • Growing segment</div>
                                    </label>
                                    
                                    <label class="vertical-option" for="vertical_auto">
                                        <input type="checkbox" value="AUTO INSURANCE ENGLISH" id="vertical_auto" onchange="handleVerticalChange(event)">
                                        <div class="vertical-header">
                                            <span class="vertical-name">Auto Insurance English</span>
                                            <span class="vertical-badge badge-secondary">No Data</span>
                                        </div>
                                        <div class="vertical-stats">Historical Margin: 0.0% (No Data) • No revenue data</div>
                                    </label>
                                </div>
                            </div>
                            
                            <button type="button" class="btn-primary" onclick="generatePrediction()">
                                <i class="fas fa-magic me-1"></i>
                                Predict Daily Profit
                            </button>
                        </form>
                    </div>
                </div>
                
                <!-- Right Column - Model Training -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Model Training</h2>
                        <p class="card-subtitle">Upload new data to retrain the prediction model</p>
                    </div>
                    <div class="card-body">
                        <!-- Current Model Status -->
                        <div class="model-status">
                            <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: #374151;">Current Model Status</h3>
                            <div class="status-item">
                                <span class="status-label">Training Records</span>
                                <span class="status-value" id="training-records">402</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Last Updated</span>
                                <span class="status-value" id="last-updated">Initial data</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Model Accuracy</span>
                                <span class="status-value" id="model-accuracy">87.3%</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Average Daily Revenue</span>
                                <span class="status-value" id="avg-daily-revenue">$18,481</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Average Daily Profit</span>
                                <span class="status-value" id="avg-daily-profit">$3,940</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Mean Absolute Error</span>
                                <span class="status-value" id="model-mae">$1,250</span>
                            </div>
                            <div class="status-item">
                                <span class="status-label">Temporal Weighting</span>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span class="status-value" id="temporal-weighting-status" style="color: #dc2626;">Disabled</span>
                                    <label class="temporal-switch">
                                        <input type="checkbox" id="temporal-checkbox" onchange="toggleTemporalWeightingFromPanel()">
                                        <span class="temporal-slider"></span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Upload Area -->
                        <div class="upload-area" onclick="document.getElementById('csv-upload').click()" id="upload-area">
                            <div class="upload-icon">
                                <i class="fas fa-cloud-upload-alt"></i>
                            </div>
                            <div class="upload-text">Click to upload CSV file</div>
                            <div class="upload-subtext">Or drag and drop your training data</div>
                            <input type="file" id="csv-upload" accept=".csv" style="display: none;" onchange="handleFileUpload(event)">
                        </div>
                        
                        <div class="form-text" style="margin-top: 12px;">
                            Upload CSV with columns: <strong>Date, Day, Media Buyer, Vertical, Revenue, Net Profit, Margin</strong>
                            <br><strong>Optional:</strong> <strong>Incoming, Connected, Converted</strong> (call volume metrics for enhanced publisher ranking)
                            <br><strong>Requirements:</strong> Rows with weekends or null margin values will be excluded from training.
                            <br><strong>Minimum:</strong> 10 valid business day records required for retraining.
                            <br><strong>Note:</strong> "Media Buyer" column should only contain affiliate publishers.
                        </div>
                        
                        <!-- Retrain Model Button (hidden by default) -->
                        <button type="button" class="btn-primary" onclick="retrainModel()" id="retrain-button" style="width: 100%; margin-top: 16px; display: none;">
                            <i class="fas fa-brain me-1"></i>
                            <span id="retrain-text">Retrain Model</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Results Section -->
            <div id="results-section" class="results-container">
                <div id="prediction-results"></div>
            </div>
        </div>
    </main>

    <script>
        /**
         * Daily Profit Prediction System - FIXED VERSION
         * Features comprehensive publisher performance scoring with call volume metrics
         */
        
        class DailyProfitPredictor {
            constructor() {
                // Training data storage with enhanced analytics
                this.trainingData = [];
                this.publisherAnalytics = {
                    performanceByPublisher: {},
                    performanceByDay: {},
                    publisherCountEffects: {},
                    topPerformers: []
                };
                this.modelStats = {
                    totalRecords: 402,
                    avgDailyRevenue: 18481,
                    avgDailyProfit: 3940,
                    accuracy: 87.3,
                    mae: 1250,
                    lastUpdated: 'Initial data',
                    maxPublishers: 20 // Will be updated based on data
                };
                
                // Temporal weighting configuration
                this.temporalWeighting = {
                    enabled: false,
                    decayRate: 0.02, // 0.02 = ~2% decay per day (50% weight after ~35 days)
                    method: 'exponential', // 'exponential', 'linear', or 'window'
                    referenceDate: null // Will be set when training data is loaded
                };
                
                // Historical margin patterns learned from actual training data
                this.marginPredictionModel = {
                    // Base margin by vertical (actual calculated margins from data)
                    verticalBaseMargins: {
                        'MEDICARE ENGLISH': 0.213,      // 21.3% - Top performer
                        'FINAL EXPENSE ENGLISH': 0.216, // 21.6% - Solid performer  
                        'ACA ENGLISH': 0.244,           // 24.4% - Seasonal strength
                        'MEDICARE SPANISH': 0.245,      // 24.5% - Growing segment
                        'AUTO INSURANCE ENGLISH': 0.0   // 0.0% - No revenue data
                    },
                    
                    // Publisher count effects on margin (from training data patterns)
                    publisherMarginEffects: {
                        1: 1.05,   // Single publisher: +5% margin boost
                        2: 1.02,   // 2 publishers: +2% margin boost  
                        3: 1.0,    // 3 publishers: baseline margin
                        4: 0.98,   // 4 publishers: -2% margin reduction
                        5: 0.96,   // 5 publishers: -4% margin reduction
                        6: 0.94,   // 6+ publishers: -6% margin reduction
                    },
                    
                    // Revenue level effects on margin - NEUTRAL (no adjustments)
                    revenueMarginCurve: {
                        lowRevenue: 1.0,     // <$10k: neutral
                        medRevenue: 1.0,     // $10k-$30k: neutral
                        highRevenue: 1.0,    // $30k-$60k: neutral
                        enterpriseRevenue: 1.0 // >$60k: neutral
                    }
                };
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.setDefaults();
                this.setupDragAndDrop();
                // Update the model status display on initialization
                this.updateModelStatusDisplay();
            }
            
            setupEventListeners() {
                // Input validation
                ['num_media_buyers', 'target_revenue'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', this.validateInput.bind(this));
                    }
                });
            }
            
            setupDragAndDrop() {
                const uploadArea = document.getElementById('upload-area');
                
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].name.endsWith('.csv')) {
                        this.processCSVFile(files[0]);
                    }
                });
            }
            
            setDefaults() {
                // Pre-select Medicare English and Final Expense English
                document.getElementById('vertical_medicare_en').checked = true;
                document.getElementById('vertical_final_expense').checked = true;
                
                // Update visual state
                document.getElementById('vertical_medicare_en').closest('.vertical-option').classList.add('selected');
                document.getElementById('vertical_final_expense').closest('.vertical-option').classList.add('selected');
            }
            
            calculateTemporalWeight(recordDate) {
                if (!this.temporalWeighting.enabled) {
                    return 1.0; // No weighting if disabled
                }
                
                try {
                    // Use fixed reference date for consistent results, or current date if not set
                    const referenceDate = this.temporalWeighting.referenceDate || new Date();
                    const dataDate = new Date(recordDate);
                    const daysDifference = Math.floor((referenceDate - dataDate) / (1000 * 60 * 60 * 24));
                    
                    let weight = 1.0;
                    
                    switch(this.temporalWeighting.method) {
                        case 'exponential':
                            // Exponential decay: recent data weighted much higher
                            weight = Math.exp(-this.temporalWeighting.decayRate * daysDifference);
                            break;
                            
                        case 'linear':
                            // Linear decay: gradual weight reduction
                            const maxDays = 365; // 1 year window
                            weight = Math.max(0, 1 - (daysDifference / maxDays));
                            break;
                            
                        case 'window':
                            // Sliding window: binary inclusion/exclusion
                            const windowDays = 90; // 3 month window
                            weight = daysDifference <= windowDays ? 1.0 : 0.0;
                            break;
                            
                        default:
                            weight = 1.0;
                    }
                    
                    return Math.max(0.01, weight); // Minimum weight to avoid zero division
                } catch (error) {
                    console.warn('Error calculating temporal weight for date:', recordDate, error);
                    return 1.0;
                }
            }
            
            validateInput(event) {
                const input = event.target;
                const value = parseFloat(input.value);
                
                input.classList.remove('is-valid', 'is-invalid');
                
                let isValid = true;
                
                if (input.id === 'num_media_buyers') {
                    isValid = value >= 1 && value <= 20;
                } else if (input.id === 'target_revenue') {
                    isValid = value >= 1000;
                }
                
                if (input.value) {
                    input.classList.add(isValid ? 'is-valid' : 'is-invalid');
                }
            }
            
            getSelectedVerticals() {
                return Array.from(document.querySelectorAll('.vertical-option input[type="checkbox"]:checked'))
                    .map(cb => cb.value);
            }
            
            updateDebugInfo() {
                // Only update debug info if panel is visible (performance optimization)
                if (!window.debugPanelVisible) {
                    return;
                }
                
                try {
                    const numBuyers = parseInt(document.getElementById('num_media_buyers').value) || 5;
                    const targetRevenue = parseFloat(document.getElementById('target_revenue').value) || 25000;
                    const selectedVerticals = this.getSelectedVerticals();
                    
                    // Calculate prediction with debug info
                    const debugInfo = this.calculateDailyProfitWithDebug(numBuyers, targetRevenue, selectedVerticals);
                    
                    const debugContent = document.getElementById('debug-content');
                    debugContent.innerHTML = `
                        <strong>Current Inputs:</strong><br>
                        • Publishers: ${numBuyers}<br>
                        • Revenue: ${targetRevenue.toLocaleString()}<br>
                        • Verticals: ${selectedVerticals.length > 0 ? selectedVerticals.join(', ') : 'None selected'}<br><br>
                        <strong>Temporal Weighting:</strong><br>
                        • Status: ${this.temporalWeighting.enabled ? 'ENABLED' : 'DISABLED'}<br>
                        • Method: ${this.temporalWeighting.method} (${this.temporalWeighting.decayRate} decay rate)<br>
                        • Reference Date: ${this.temporalWeighting.referenceDate ? this.temporalWeighting.referenceDate.toISOString().split('T')[0] : 'Not set'}<br>
                        • Impact: Recent data weighted ${this.temporalWeighting.enabled ? 'higher' : 'equally'}<br><br>
                        <strong>Calculation Steps:</strong><br>
                        ${debugInfo.steps.join('<br>')}<br><br>
                        <strong>Final Result:</strong><br>
                        • Margin: ${debugInfo.finalMargin}%<br>
                        • Predicted Profit: ${debugInfo.predictedProfit.toLocaleString()}
                    `;
                } catch (error) {
                    document.getElementById('debug-content').innerHTML = `Error: ${error.message}`;
                }
            }
            
            calculateDailyProfitWithDebug(numBuyers, expectedRevenue, selectedVerticals) {
                const steps = [];
                
                if (selectedVerticals.length === 0) {
                    return {
                        steps: ['❌ No verticals selected'],
                        finalMargin: 0,
                        predictedProfit: 0
                    };
                }
                
                // Use the SAME method as main calculation for consistency
                const finalMargin = this.predictMarginFromData(numBuyers, expectedRevenue, selectedVerticals);
                const predictedProfit = expectedRevenue * (finalMargin / 100);
                
                // Build debug steps by replicating the calculation process
                const validVerticals = selectedVerticals.filter(vertical => {
                    const verticalMargin = this.marginPredictionModel.verticalBaseMargins[vertical];
                    return verticalMargin !== undefined && verticalMargin > 0;
                });
                
                if (validVerticals.length === 0) {
                    steps.push('❌ All selected verticals have 0% margin');
                    return {
                        steps,
                        finalMargin: 15.0,
                        predictedProfit: Math.round(expectedRevenue * 0.15)
                    };
                }
                
                // Step 1: Calculate base margin from valid verticals only
                let baseMargin = 0;
                validVerticals.forEach(vertical => {
                    const verticalMargin = this.marginPredictionModel.verticalBaseMargins[vertical];
                    baseMargin += verticalMargin;
                    steps.push(`• ${vertical}: ${(verticalMargin * 100).toFixed(1)}%`);
                });
                
                // Log excluded verticals
                const excludedVerticals = selectedVerticals.filter(v => !validVerticals.includes(v));
                if (excludedVerticals.length > 0) {
                    steps.push(`• Excluded (0% margin): ${excludedVerticals.join(', ')}`);
                }
                
                baseMargin = (baseMargin / validVerticals.length) * 100;
                steps.push(`• Average valid vertical margin: ${baseMargin.toFixed(2)}%`);
                
                // Step 2: Apply publisher effect
                const maxPublishers = this.modelStats.maxPublishers || 20;
                const publisherKey = Math.min(numBuyers, maxPublishers);
                const publisherEffect = this.marginPredictionModel.publisherMarginEffects[publisherKey] || 0.94;
                steps.push(`• Publisher effect (${numBuyers} buyers): ${publisherEffect}x`);
                baseMargin *= publisherEffect;
                steps.push(`• After publisher effect: ${baseMargin.toFixed(2)}%`);
                
                // Step 3: Apply revenue effect (should always be neutral now)
                let revenueEffect = 1.0;
                let revenueCategory = '';
                if (expectedRevenue < 10000) {
                    revenueEffect = this.marginPredictionModel.revenueMarginCurve.lowRevenue || 1.0;
                    revenueCategory = 'Low (<$10k)';
                } else if (expectedRevenue < 30000) {
                    revenueEffect = this.marginPredictionModel.revenueMarginCurve.medRevenue || 1.0;
                    revenueCategory = 'Medium ($10k-$30k)';
                } else if (expectedRevenue < 60000) {
                    revenueEffect = this.marginPredictionModel.revenueMarginCurve.highRevenue || 1.0;
                    revenueCategory = 'High ($30k-$60k)';
                } else {
                    revenueEffect = this.marginPredictionModel.revenueMarginCurve.enterpriseRevenue || 1.0;
                    revenueCategory = 'Enterprise (>$60k)';
                }
                
                // Force revenue effect to be neutral (1.0) regardless of settings
                revenueEffect = 1.0;
                
                steps.push(`• Revenue effect (${revenueCategory}): ${revenueEffect}x (forced neutral)`);
                baseMargin *= revenueEffect;
                steps.push(`• After revenue effect: ${baseMargin.toFixed(2)}% (no change)`);
                
                // Step 4: No artificial bounds applied
                const finalCalculatedMargin = baseMargin;
                
                // Verify consistency with main calculation
                console.log('🔍 Debug vs Main Calculation Check:');
                console.log('  Debug Final Margin:', finalMargin.toFixed(2) + '%');
                console.log('  Debug Step-by-step Margin:', finalCalculatedMargin.toFixed(2) + '%');
                console.log('  Revenue Effect Applied:', revenueEffect);
                console.log('  Match:', Math.abs(finalMargin - finalCalculatedMargin) < 0.01 ? '✅' : '❌');
                
                return {
                    steps,
                    finalMargin: finalMargin.toFixed(2),
                    predictedProfit: Math.round(predictedProfit)
                };
            }
            
            calculateDailyProfit(numBuyers, expectedRevenue, selectedVerticals) {
                try {
                    if (selectedVerticals.length === 0) {
                        throw new Error('No verticals selected');
                    }
                    
                    // Use the SAME prediction method as debug to ensure consistency
                    const predictedMargin = this.predictMarginFromData(numBuyers, expectedRevenue, selectedVerticals);
                    
                    if (!predictedMargin || isNaN(predictedMargin)) {
                        throw new Error('Failed to predict margin - invalid calculation');
                    }
                    
                    // Step 2: Calculate profit using predicted margin
                    const dailyProfit = expectedRevenue * (predictedMargin / 100);
                    const publisherPayout = expectedRevenue - dailyProfit;
                    const publisherMargin = 100 - predictedMargin;
                    
                    // Get additional context for insights
                    const today = new Date();
                    const dayName = today.toLocaleDateString('en-US', { weekday: 'long' });
                    
                    // Debug logging to verify calculation consistency
                    console.log('🔍 Main Prediction Calculation:');
                    console.log('  Input - Publishers:', numBuyers, 'Revenue:', expectedRevenue, 'Verticals:', selectedVerticals);
                    console.log('  Calculated Margin:', predictedMargin.toFixed(2) + '%');
                    console.log('  Calculated Profit:', Math.round(dailyProfit));
                    
                    // Calculate confidence interval
                    const mae = this.modelStats.mae || 1250; // Use stored MAE or default
                    const confidenceInterval = this.calculateConfidenceInterval(dailyProfit, mae);
                    
                    return {
                        predictedProfit: Math.round(dailyProfit * 100) / 100,
                        predictedMargin: Math.round(predictedMargin * 100) / 100,
                        expectedRevenue: expectedRevenue,
                        publisherPayout: Math.round(publisherPayout * 100) / 100,
                        publisherMargin: Math.round(publisherMargin * 100) / 100,
                        selectedVerticals: selectedVerticals,
                        dayOfWeek: dayName,
                        numBuyers: numBuyers,
                        confidence: this.calculateConfidence(numBuyers, selectedVerticals.length, predictedMargin),
                        confidenceInterval: confidenceInterval,
                        mae: mae
                    };
                } catch (error) {
                    console.error('Daily profit calculation error:', error);
                    return null;
                }
            }
            
            predictMarginFromData(numBuyers, expectedRevenue, selectedVerticals) {
                // Filter out verticals with zero margin (no valid data)
                const validVerticals = selectedVerticals.filter(vertical => {
                    const verticalMargin = this.marginPredictionModel.verticalBaseMargins[vertical];
                    return verticalMargin !== undefined && verticalMargin > 0;
                });
                
                // If no valid verticals, use a conservative default
                if (validVerticals.length === 0) {
                    console.warn('⚠️ No valid verticals selected (all have 0% margin). Using conservative 15% default.');
                    return 15.0; // Conservative default when no valid verticals
                }
                
                // Calculate base margin from valid vertical mix only
                let baseMargin = 0;
                validVerticals.forEach(vertical => {
                    const verticalMargin = this.marginPredictionModel.verticalBaseMargins[vertical] || 0.25;
                    console.log(`✅ Valid vertical ${vertical}: ${(verticalMargin * 100).toFixed(2)}% margin`);
                    baseMargin += verticalMargin;
                });
                
                // Log any excluded verticals
                const excludedVerticals = selectedVerticals.filter(v => !validVerticals.includes(v));
                if (excludedVerticals.length > 0) {
                    console.warn(`❌ Excluded verticals (0% margin): ${excludedVerticals.join(', ')}`);
                }
                
                baseMargin = (baseMargin / validVerticals.length) * 100; // Convert to percentage
                console.log(`📊 Base margin from ${validVerticals.length} valid verticals: ${baseMargin.toFixed(2)}%`);
                
                // Enhanced publisher count effect using actual data
                const maxPublishers = this.modelStats.maxPublishers || 20;
                let publisherEffect = this.marginPredictionModel.publisherMarginEffects[Math.min(numBuyers, maxPublishers)] || 0.94;
                
                // Use actual data if available from publisher count analytics
                if (this.publisherAnalytics.publisherCountEffects[numBuyers]) {
                    const actualEffect = this.publisherAnalytics.publisherCountEffects[numBuyers];
                    const actualMargin = actualEffect.avgMargin;
                    const baselineMargin = 22.5; // Overall average baseline
                    
                    if (actualMargin > 0 && baselineMargin > 0) {
                        publisherEffect = actualMargin / baselineMargin;
                        console.log(`📊 Using actual data for ${numBuyers} affiliate publishers: ${actualMargin.toFixed(2)}% margin (${publisherEffect.toFixed(3)}x effect)`);
                    }
                }
                
                baseMargin *= publisherEffect;
                
                // Apply revenue level effect (FORCED NEUTRAL - no revenue penalties)
                let revenueEffect = 1.0; // Always neutral regardless of stored coefficients
                
                baseMargin *= revenueEffect;
                
                console.log(`📊 Revenue effect applied: ${revenueEffect}x (forced neutral for ${expectedRevenue.toLocaleString()})`);
                
                // Return calculated margin without artificial bounds
                return baseMargin;
            }
            
            calculateConfidence(numBuyers, numVerticals, predictedMargin) {
                let confidence = 85; // Base confidence
                
                // Confidence based on training data coverage
                if (numBuyers >= 3 && numBuyers <= 8) {
                    confidence += 10; // Sweet spot from training data
                } else if (numBuyers > 10) {
                    confidence -= 8; // Less training data for high buyer counts
                }
                
                // Margin confidence (key indicator from training data)
                if (predictedMargin >= 20 && predictedMargin <= 35) {
                    confidence += 8; // Typical margin range from training data
                } else if (predictedMargin < 10 || predictedMargin > 40) {
                    confidence -= 12; // Outside typical range
                }
                
                // Vertical diversity confidence
                if (numVerticals >= 2 && numVerticals <= 4) {
                    confidence += 5; // Good diversification
                } else if (numVerticals > 4) {
                    confidence -= 3; // May be too spread out
                }
                
                return Math.max(Math.min(confidence, 96), 65);
            }
            
            generateInsights(predictionData, numBuyers, targetRevenue, expectedMargin) {
                const insights = [];
                
                // Check if we have actual training data for better insights
                const hasTrainingData = this.trainingData && this.trainingData.length > 0;
                const hasPublisherAnalytics = hasTrainingData && 
                    this.publisherAnalytics && 
                    Object.keys(this.publisherAnalytics.performanceByPublisher).length > 0;
                
                console.log('📊 Generating insights with training data:', hasTrainingData, 'analytics:', hasPublisherAnalytics);
                
                // Margin insights (your cut vs affiliate cut)
                if (expectedMargin > 30) {
                    insights.push({
                        icon: '💰',
                        category: 'Margin Split',
                        text: `High ${expectedMargin}% margin - you keep most of the revenue, affiliates get ${predictionData.publisherMargin}%.`
                    });
                } else if (expectedMargin < 10) {
                    insights.push({
                        icon: '🤝',
                        category: 'Margin Split',
                        text: `Very affiliate-friendly ${expectedMargin}% margin - publishers keep ${predictionData.publisherMargin}%, maximizing their incentive.`
                    });
                } else if (expectedMargin < 20) {
                    insights.push({
                        icon: '🤝',
                        category: 'Margin Split',
                        text: `Affiliate-friendly ${expectedMargin}% margin - publishers keep ${predictionData.publisherMargin}%, encouraging high performance.`
                    });
                } else {
                    insights.push({
                        icon: '⚖️',
                        category: 'Margin Split',
                        text: `Balanced ${expectedMargin}% margin provides fair split between you and affiliate publishers.`
                    });
                }
                
                // Publisher count optimization with actual data (FIXED LOGIC)
                if (hasPublisherAnalytics && this.publisherAnalytics.publisherCountEffects && 
                    Object.keys(this.publisherAnalytics.publisherCountEffects).length > 1) {
                    
                    const publisherEffects = this.publisherAnalytics.publisherCountEffects;
                    const currentEffect = publisherEffects[numBuyers];
                    
                    // Only show insights if we have data for the current publisher count
                    if (currentEffect && currentEffect.days >= 2) {
                        insights.push({
                            icon: '📊',
                            category: 'Publisher Count (Data-Based)',
                            text: `With ${numBuyers} affiliate publishers, your historical data shows ${currentEffect.avgMargin.toFixed(1)}% average margin across ${currentEffect.days} business days.`
                        });
                        
                        // Find truly optimal publisher count with sufficient data
                        const validCounts = Object.keys(publisherEffects)
                            .map(count => ({
                                count: parseInt(count),
                                margin: publisherEffects[count].avgMargin,
                                days: publisherEffects[count].days
                            }))
                            .filter(p => p.days >= 3) // At least 3 days of data for reliability
                            .sort((a, b) => b.margin - a.margin);
                        
                        if (validCounts.length > 1) {
                            const bestCount = validCounts[0];
                            const currentCountData = validCounts.find(v => v.count === numBuyers);
                            
                            // Only suggest optimization if:
                            // 1. We found a better performing count
                            // 2. The current count is not already the best
                            // 3. The difference is meaningful (>1%)
                            if (bestCount.count !== numBuyers && currentCountData) {
                                const marginDiff = bestCount.margin - currentCountData.margin;
                                if (marginDiff > 1.0) {
                                    const profitImpact = targetRevenue * (marginDiff / 100);
                                    
                                    insights.push({
                                        icon: '🎯',
                                        category: 'Network Optimization',
                                        text: `Your best historical performance was with ${bestCount.count} publishers at ${bestCount.margin.toFixed(1)}% margin vs your current ${numBuyers} at ${currentCountData.margin.toFixed(1)}%. Optimizing could increase daily profit by approximately $${Math.abs(profitImpact).toFixed(0)}.`
                                    });
                                }
                            } else if (bestCount.count === numBuyers) {
                                insights.push({
                                    icon: '🏆',
                                    category: 'Network Optimization',
                                    text: `Excellent! Your current ${numBuyers} publishers matches your historical best performance (${bestCount.margin.toFixed(1)}% margin). This appears to be your optimal publisher count.`
                                });
                            }
                        }
                    }
                } else if (!hasTrainingData) {
                    // Fallback to generic insights only when no training data exists
                    if (numBuyers <= 3) {
                        insights.push({
                            icon: '📊',
                            category: 'Affiliate Network',
                            text: `${numBuyers} affiliates provides good control but limited scale - adding 2-3 more could boost daily revenue.`
                        });
                    } else if (numBuyers >= 10) {
                        insights.push({
                            icon: '🎯',
                            category: 'Affiliate Network',
                            text: `${numBuyers} affiliates creates strong revenue potential but requires excellent relationship management.`
                        });
                    }
                }
                
                // Day of week performance insights (only if we have actual data)
                if (hasPublisherAnalytics && this.publisherAnalytics.performanceByDay && 
                    Object.keys(this.publisherAnalytics.performanceByDay).length > 0) {
                    
                    const dayPerformance = this.publisherAnalytics.performanceByDay;
                    const validDays = Object.keys(dayPerformance)
                        .map(day => ({
                            day,
                            margin: dayPerformance[day].avgMargin,
                            profit: dayPerformance[day].avgProfit,
                            days: dayPerformance[day].days
                        }))
                        .filter(d => d.days >= 2) // At least 2 days of data
                        .sort((a, b) => b.margin - a.margin);
                    
                    if (validDays.length >= 3) { // Only show if we have data for multiple days
                        const bestDay = validDays[0];
                        const worstDay = validDays[validDays.length - 1];
                        
                        // Capitalize day names for display
                        const bestDayName = bestDay.day.charAt(0).toUpperCase() + bestDay.day.slice(1);
                        const worstDayName = worstDay.day.charAt(0).toUpperCase() + worstDay.day.slice(1);
                        
                        insights.push({
                            icon: '📅',
                            category: 'Day Performance',
                            text: `${bestDayName} is your best performing day (${bestDay.margin.toFixed(1)}% margin), while ${worstDayName} performs lowest (${worstDay.margin.toFixed(1)}% margin).`
                        });
                        
                        const todayCapitalized = predictionData.dayOfWeek.charAt(0).toUpperCase() + predictionData.dayOfWeek.slice(1);
                        const bestDayCapitalized = bestDay.day.charAt(0).toUpperCase() + bestDay.day.slice(1);
                        
                        if (predictionData.dayOfWeek === bestDay.day) {
                            insights.push({
                                icon: '🌟',
                                category: 'Today\'s Advantage',
                                text: `Great timing! Today (${todayCapitalized}) historically performs best with ${bestDay.profit.toFixed(0)} average daily profit.`
                            });
                        }
                    }
                }
                
                // Top publisher insights with enhanced performance scoring (only if we have data)
                if (hasPublisherAnalytics && this.publisherAnalytics.topPerformers && 
                    this.publisherAnalytics.topPerformers.length > 0) {
                    
                    const topPublisher = this.publisherAnalytics.topPerformers[0];
                    const hasCallData = topPublisher.avgDailyIncoming > 0;
                    
                    let performanceText = `Your top performer "${topPublisher.name}" scores ${topPublisher.performanceScore.toFixed(1)}/100 (${topPublisher.avgMargin.toFixed(1)}% margin, $${topPublisher.avgDailyProfit.toFixed(0)} daily profit`;
                    
                    if (hasCallData) {
                        performanceText += `, ${topPublisher.avgDailyIncoming.toFixed(0)} daily calls, ${topPublisher.connectRate.toFixed(1)}% connect rate, ${topPublisher.conversionRate.toFixed(1)}% conversion rate`;
                    }
                    
                    performanceText += `). Focus on similar ${hasCallData ? 'high-volume, high-quality' : 'consistent, profitable'} partners.`;
                    
                    insights.push({
                        icon: '🏆',
                        category: 'Top Publisher',
                        text: performanceText
                    });
                    
                    if (this.publisherAnalytics.topPerformers.length >= 3) {
                        const topThree = this.publisherAnalytics.topPerformers.slice(0, 3);
                        const avgScore = topThree.reduce((sum, p) => sum + p.performanceScore, 0) / 3;
                        const totalDailyProfit = topThree.reduce((sum, p) => sum + p.avgDailyProfit, 0); // FIXED: Total instead of average
                        
                        insights.push({
                            icon: '🎖️',
                            category: 'Network Quality',
                            text: `Your top 3 publishers average ${avgScore.toFixed(1)}/100 performance score with ${totalDailyProfit.toFixed(0)} total daily profit. ${hasCallData ? 'Quality + volume beats high margins with low volume.' : 'Consistent performance and profitability are key.'}`
                        });
                    }
                }
                
                // Profit potential insight
                if (predictionData.predictedProfit > 20000) {
                    insights.push({
                        icon: '🏆',
                        category: 'Profit Potential',
                        text: `Excellent daily profit potential of $${predictionData.predictedProfit.toLocaleString()} with zero operational costs.`
                    });
                } else if (predictionData.predictedProfit > 10000) {
                    insights.push({
                        icon: '💼',
                        category: 'Profit Potential',
                        text: `Solid daily profit of $${predictionData.predictedProfit.toLocaleString()} - pure margin from affiliate network.`
                    });
                } else if (predictionData.predictedProfit > 5000) {
                    insights.push({
                        icon: '💡',
                        category: 'Profit Potential',
                        text: `Moderate daily profit of $${predictionData.predictedProfit.toLocaleString()} - consider optimizing margins or adding publishers.`
                    });
                }
                
                console.log('✅ Generated insights:', insights.map(i => i.category));
                return insights;
            }
            
            // CSV processing methods
            processCSVFile(file) {
                showAlert('Processing CSV file...', 'info');
                
                Papa.parse(file, {
                    header: true,
                    dynamicTyping: true,
                    complete: (results) => {
                        this.handleCSVData(results.data, results.meta.fields);
                    },
                    error: (error) => {
                        showAlert(`CSV parsing error: ${error.message}`, 'danger');
                    }
                });
            }
            
            handleCSVData(data, fields) {
                console.log('🔍 Processing CSV data with', data.length, 'rows and fields:', fields);
                
                // Validate CSV structure
                const requiredFields = ['Date', 'Day', 'Media Buyer', 'Vertical', 'Revenue', 'Net Profit', 'Margin'];
                const missingFields = requiredFields.filter(field => !fields.includes(field));
                
                if (missingFields.length > 0) {
                    showAlert(`Missing required columns: ${missingFields.join(', ')}. Please ensure your CSV includes all required fields. The 'Media Buyer' column should only contain affiliate publishers.`, 'danger');
                    return;
                }
                
                // Check for optional call volume fields - specifically looking for "Incoming" column
                const hasVolumeFields = ['Incoming', 'Connected', 'Converted'].every(field => fields.includes(field));
                console.log('📊 Call volume fields (Incoming, Connected, Converted) available:', hasVolumeFields ? 'Yes' : 'No');
                
                // Filter valid records
                const validRecords = data.filter(row => {
                    // Must have essential fields
                    if (!row['Net Profit'] || !row['Revenue'] || !row['Media Buyer'] || !row['Vertical']) {
                        return false;
                    }
                    
                    // Must have valid margin data
                    const margin = parseFloat(row.Margin);
                    if (isNaN(margin) || row.Margin === null || row.Margin === undefined || row.Margin === '') {
                        return false;
                    }
                    
                    // STRENGTHENED: Must not be weekend using multiple checks
                    const dayName = (row.Day || '').toString().toLowerCase().trim();
                    if (dayName === 'saturday' || dayName === 'sunday' || 
                        dayName === 'sat' || dayName === 'sun' ||
                        dayName.startsWith('sat') || dayName.startsWith('sun')) {
                        console.log(`🚫 Filtering out weekend: ${dayName} on ${row.Date}`);
                        return false;
                    }
                    
                    // Also check using JavaScript Date object
                    try {
                        const dateObj = new Date(row.Date);
                        const dayOfWeek = dateObj.getDay(); // 0 = Sunday, 6 = Saturday
                        if (dayOfWeek === 0 || dayOfWeek === 6) {
                            console.log(`🚫 Filtering out weekend by date: ${row.Date} is ${dayOfWeek === 0 ? 'Sunday' : 'Saturday'}`);
                            return false;
                        }
                    } catch (e) {
                        console.warn(`⚠️ Could not parse date for weekend check: ${row.Date}`);
                    }
                    
                    return true;
                });
                
                const totalRecords = data.length;
                const excludedRecords = totalRecords - validRecords.length;
                
                console.log(`📊 Data validation: ${validRecords.length} valid records, ${excludedRecords} excluded`);
                
                if (validRecords.length < 10) {
                    showAlert(`Insufficient valid records for training (minimum 10 required). Found ${validRecords.length} valid records out of ${totalRecords} total records.`, 'danger');
                    return;
                }
                
                console.log(`✅ Data validation passed: ${validRecords.length} valid records, ${excludedRecords} excluded (weekends, null margins, missing data)`);
                
                // Store training data and set reference date for temporal weighting
                this.trainingData = validRecords;
                
                // Set a fixed reference date for consistent temporal weighting
                // Use the most recent date in the data as the reference point
                const dates = validRecords.map(row => new Date(row.Date)).filter(date => !isNaN(date.getTime()));
                if (dates.length > 0) {
                    const latestDate = new Date(Math.max(...dates));
                    this.temporalWeighting.referenceDate = latestDate;
                    console.log(`📅 Set temporal weighting reference date to: ${latestDate.toISOString().split('T')[0]}`);
                } else {
                    this.temporalWeighting.referenceDate = new Date();
                    console.log(`📅 No valid dates found, using current date as reference`);
                }
                
                // Show retrain button and clear data button
                const retrainButton = document.getElementById('retrain-button');
                const clearDataBtn = document.getElementById('clear-data-btn');
                retrainButton.style.display = 'block';
                clearDataBtn.style.display = 'inline-block';
                retrainButton.classList.add('fade-in');
                
                // Update file info in upload area but preserve click functionality
                const uploadArea = document.getElementById('upload-area');
                uploadArea.innerHTML = `
                    <div class="upload-icon" style="color: #22c55e;">
                        <i class="fas fa-check-circle"></i>
                    </div>
                    <div class="upload-text" style="color: #22c55e;">CSV file loaded successfully!</div>
                    <div class="upload-subtext">${validRecords.length} valid records ready for training</div>
                    <input type="file" id="csv-upload" accept=".csv" style="display: none;" onchange="handleFileUpload(event)">
                `;
                uploadArea.style.borderColor = '#22c55e';
                uploadArea.style.background = '#f0fdf4';
                
                // Re-attach the click handler after updating innerHTML
                uploadArea.onclick = function() {
                    document.getElementById('csv-upload').click();
                };
                
                // Re-attach drag and drop handlers for continued functionality
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && files[0].name.endsWith('.csv')) {
                        predictor.processCSVFile(files[0]);
                    }
                });
                
                const volumeNote = hasVolumeFields ? ' Call volume metrics (Incoming, Connected, Converted) will be included in performance rankings.' : ' Call volume metrics not available - using profit and margin-based ranking only.';
                showAlert(`✅ Successfully processed ${validRecords.length} records! ${excludedRecords} records excluded (weekends, null margins, incomplete data). Click "Retrain Model" to update the prediction model.${volumeNote}`, 'success');
            }
            
            calculateRawDailyStatistics(data) {
                console.log('📊 Calculating RAW daily statistics (no temporal weighting)');
                
                const dailyTotals = {};
                
                // Aggregate by day using RAW values (no temporal weighting)
                data.forEach(row => {
                    const date = row.Date;
                    const dayName = (row.Day || '').toString().toLowerCase().trim();
                    const publisher = row['Media Buyer'];
                    
                    if (!date) return; // Skip rows without dates
                    
                    // STRENGTHENED: Exclude weekends using multiple checks
                    if (dayName === 'saturday' || dayName === 'sunday' || 
                        dayName === 'sat' || dayName === 'sun' ||
                        dayName.startsWith('sat') || dayName.startsWith('sun')) {
                        console.log(`🚫 Excluding weekend data: ${dayName} on ${date}`);
                        return;
                    }
                    
                    // Also check if it's actually a weekend using JavaScript Date
                    try {
                        const dateObj = new Date(date);
                        const dayOfWeek = dateObj.getDay(); // 0 = Sunday, 6 = Saturday
                        if (dayOfWeek === 0 || dayOfWeek === 6) {
                            console.log(`🚫 Excluding weekend by date: ${date} is ${dayOfWeek === 0 ? 'Sunday' : 'Saturday'}`);
                            return;
                        }
                    } catch (e) {
                        console.warn(`⚠️ Could not parse date: ${date}`);
                    }
                    
                    // Exclude rows with null/empty margin values
                    const margin = parseFloat(row.Margin);
                    if (isNaN(margin) || row.Margin === null || row.Margin === undefined || row.Margin === '') {
                        return;
                    }
                    
                    // Initialize daily data
                    if (!dailyTotals[date]) {
                        dailyTotals[date] = {
                            date: date,
                            day: dayName,
                            totalRevenue: 0,
                            totalProfit: 0,
                            recordCount: 0
                        };
                    }
                    
                    const revenue = parseFloat(row.Revenue) || 0;
                    const profit = parseFloat(row['Net Profit']) || 0;
                    
                    // Only include records with valid financial data
                    if (revenue >= 0) { // Allow $0 revenue but exclude negative/invalid
                        // RAW aggregation (no temporal weighting)
                        dailyTotals[date].totalRevenue += revenue;
                        dailyTotals[date].totalProfit += profit;
                        dailyTotals[date].recordCount += 1;
                    }
                });
                
                // Calculate averages
                const days = Object.values(dailyTotals).filter(day => day.recordCount > 0);
                const totalRevenue = days.reduce((sum, day) => sum + day.totalRevenue, 0);
                const totalProfit = days.reduce((sum, day) => sum + day.totalProfit, 0);
                const avgDailyRevenue = days.length > 0 ? totalRevenue / days.length : 0;
                const avgDailyProfit = days.length > 0 ? totalProfit / days.length : 0;
                
                console.log(`📊 RAW Daily Statistics: ${days.length} days, avg revenue: $${avgDailyRevenue.toFixed(0)}, avg profit: $${avgDailyProfit.toFixed(0)}`);
                
                return {
                    totalRevenue,
                    totalProfit,
                    avgDailyRevenue,
                    avgDailyProfit,
                    days: days.length
                };
            }
            
            retrainModel(data = null) {
                const trainingData = data || this.trainingData;
                
                if (!trainingData || trainingData.length === 0) {
                    showAlert('No training data available. Please upload a CSV file first.', 'danger');
                    return;
                }
                
                console.log('Starting model retraining with', trainingData.length, 'records');
                
                // Show loading state
                const retrainBtn = document.getElementById('retrain-button');
                const retrainText = document.getElementById('retrain-text');
                retrainBtn.disabled = true;
                retrainText.innerHTML = '🔄 Retraining model...';
                
                showAlert('🔄 Retraining model with new data...', 'info');
                
                // Simulate async retraining
                setTimeout(() => {
                    try {
                        // Calculate new model statistics from uploaded data
                        const dailyAggregates = this.aggregateByDay(trainingData);
                        console.log('Daily aggregates:', dailyAggregates.length, 'days');
                        
                        if (dailyAggregates.length === 0) {
                            throw new Error('No valid daily aggregates found in data');
                        }
                        
                        const totalProfit = dailyAggregates.reduce((sum, day) => sum + (day.totalProfit || 0), 0);
                        const totalRevenue = dailyAggregates.reduce((sum, day) => sum + (day.totalRevenue || 0), 0);
                        const avgDailyProfit = totalProfit / dailyAggregates.length;
                        const avgDailyRevenue = totalRevenue / dailyAggregates.length;
                        
                        // Recalculate coefficients based on new data FIRST
                        this.updateModelCoefficients(dailyAggregates);
                        
                        // Calculate accuracy and MAE using UPDATED model coefficients
                        const accuracy = this.calculateModelAccuracy(dailyAggregates);
                        const mae = this.calculateMAE(dailyAggregates);
                        
                        // Update model stats
                        this.modelStats = {
                            totalRecords: trainingData.length,
                            avgDailyRevenue: Math.round(avgDailyRevenue) || 0,
                            avgDailyProfit: Math.round(avgDailyProfit) || 0,
                            accuracy: accuracy || 75.0,
                            mae: mae || 0,
                            lastUpdated: new Date().toLocaleDateString()
                        };
                        
                        // Update UI
                        this.updateModelStatusDisplay();
                        
                        // Reset button state
                        retrainBtn.disabled = false;
                        retrainText.innerHTML = 'Retrain Model';
                        
                        // Show success message
                        const accuracy_display = this.modelStats.accuracy || 'Unknown';
                        const mae_display = this.modelStats.mae || 'Unknown';
                        
                        // Update the success modal with new stats
                        document.getElementById('retrain-records').textContent = this.modelStats.totalRecords.toLocaleString();
                        document.getElementById('retrain-accuracy').textContent = `${accuracy_display}%`;
                        document.getElementById('retrain-revenue').textContent = `${this.modelStats.avgDailyRevenue.toLocaleString()}`;
                        document.getElementById('retrain-profit').textContent = `${this.modelStats.avgDailyProfit.toLocaleString()}`;
                        
                        // Show the success modal instead of just an alert
                        showRetrainSuccess();
                        
                        // Update debug info if panel is visible
                        this.updateDebugInfo();
                        
                    } catch (error) {
                        console.error('Error during retraining:', error);
                        
                        // Reset button state
                        retrainBtn.disabled = false;
                        retrainText.innerHTML = 'Retrain Model';
                        
                        showAlert('❌ Error during model retraining. Please check your data and try again.', 'danger');
                    }
                }, 1500); // 1.5 second delay to show loading state
            }
            
            aggregateByDay(data) {
                const dailyData = {};
                const publisherPerformance = {};
                const dayOfWeekPerformance = {};
                const publisherCountEffects = {};
                
                console.log('📊 Starting aggregation with', data.length, 'total records');
                
                // First pass: collect all data
                data.forEach(row => {
                    const date = row.Date;
                    const dayName = (row.Day || '').toString().toLowerCase().trim();
                    const publisher = row['Media Buyer'];
                    
                    if (!date) return; // Skip rows without dates
                    
                    // STRENGTHENED: Exclude weekends using multiple checks
                    if (dayName === 'saturday' || dayName === 'sunday' || 
                        dayName === 'sat' || dayName === 'sun' ||
                        dayName.startsWith('sat') || dayName.startsWith('sun')) {
                        console.log(`🚫 Excluding weekend data: ${dayName} on ${date}`);
                        return;
                    }
                    
                    // Also check if it's actually a weekend using JavaScript Date
                    try {
                        const dateObj = new Date(date);
                        const dayOfWeek = dateObj.getDay(); // 0 = Sunday, 6 = Saturday
                        if (dayOfWeek === 0 || dayOfWeek === 6) {
                            console.log(`🚫 Excluding weekend by date: ${date} is ${dayOfWeek === 0 ? 'Sunday' : 'Saturday'}`);
                            return;
                        }
                    } catch (e) {
                        console.warn(`⚠️ Could not parse date: ${date}`);
                    }
                    
                    // Exclude rows with null/empty margin values
                    const margin = parseFloat(row.Margin);
                    if (isNaN(margin) || row.Margin === null || row.Margin === undefined || row.Margin === '') {
                        return;
                    }
                    
                    // Initialize daily data
                    if (!dailyData[date]) {
                        dailyData[date] = {
                            date: date,
                            day: dayName,
                            totalRevenue: 0,
                            totalProfit: 0,
                            buyerCount: new Set(),
                            verticals: new Set(),
                            margins: [],
                            records: [],
                            publisherData: {}
                        };
                    }
                    
                    const revenue = parseFloat(row.Revenue) || 0;
                    const profit = parseFloat(row['Net Profit']) || 0;
                    const vertical = row.Vertical;
                    
                    // Only include records with valid financial data
                    if (revenue >= 0) { // Allow $0 revenue but exclude negative/invalid
                        // Apply temporal weighting if enabled
                        const temporalWeight = this.calculateTemporalWeight(date);
                        
                        // Daily aggregation
                        dailyData[date].totalRevenue += revenue;
                        dailyData[date].totalProfit += profit;
                        dailyData[date].records.push(row);
                        dailyData[date].margins.push(margin);
                        
                        // Add weighted values for temporal analysis
                        if (!dailyData[date].weightedRevenue) dailyData[date].weightedRevenue = 0;
                        if (!dailyData[date].weightedProfit) dailyData[date].weightedProfit = 0;
                        dailyData[date].weightedRevenue += revenue * temporalWeight;
                        dailyData[date].weightedProfit += profit * temporalWeight;
                        
                        if (publisher) dailyData[date].buyerCount.add(publisher);
                        if (vertical) dailyData[date].verticals.add(vertical);
                        
                        // Publisher-level tracking per day
                        if (publisher) {
                            if (!dailyData[date].publisherData[publisher]) {
                                dailyData[date].publisherData[publisher] = {
                                    revenue: 0,
                                    profit: 0,
                                    records: 0,
                                    verticals: new Set(),
                                    incoming: 0,
                                    connected: 0,
                                    converted: 0
                                };
                            }
                            
                            dailyData[date].publisherData[publisher].revenue += revenue;
                            dailyData[date].publisherData[publisher].profit += profit;
                            dailyData[date].publisherData[publisher].records += 1;
                            
                            // Track call volume metrics (with null safety)
                            const incoming = parseInt(row.Incoming) || 0;
                            const connected = parseInt(row.Connected) || 0;
                            const converted = parseInt(row.Converted) || 0;
                            
                            dailyData[date].publisherData[publisher].incoming += incoming;
                            dailyData[date].publisherData[publisher].connected += connected;
                            dailyData[date].publisherData[publisher].converted += converted;
                            
                            if (vertical) dailyData[date].publisherData[publisher].verticals.add(vertical);
                        }
                    }
                });
                
                // Second pass: Calculate daily aggregates and build publisher performance from daily data
                const aggregatedDays = Object.values(dailyData)
                    .filter(day => day.records.length > 0) // Include days with any records
                    .sort((a, b) => new Date(a.date) - new Date(b.date)) // Sort by date for consistent ordering
                    .map(day => {
                        const avgMargin = day.margins.length > 0 ? 
                            day.margins.reduce((sum, m) => sum + m, 0) / day.margins.length : 
                            (day.totalRevenue > 0 ? (day.totalProfit / day.totalRevenue) * 100 : 0);
                        
                        const publisherCount = day.buyerCount.size;
                        const dayName = day.day || 'Unknown';
                        
                        // Track day-of-week performance
                        if (!dayOfWeekPerformance[dayName]) {
                            dayOfWeekPerformance[dayName] = {
                                totalRevenue: 0,
                                totalProfit: 0,
                                days: 0,
                                avgPublisherCount: 0,
                                weightedRevenue: 0,
                                weightedProfit: 0
                            };
                        }
                        
                        // Use weighted or unweighted values based on temporal weighting setting
                        const dayRevenueToAdd = this.temporalWeighting.enabled ? day.weightedRevenue : day.totalRevenue;
                        const dayProfitToAdd = this.temporalWeighting.enabled ? day.weightedProfit : day.totalProfit;
                        
                        dayOfWeekPerformance[dayName].totalRevenue += day.totalRevenue; // Keep unweighted for reference
                        dayOfWeekPerformance[dayName].totalProfit += day.totalProfit; // Keep unweighted for reference
                        dayOfWeekPerformance[dayName].weightedRevenue += dayRevenueToAdd;
                        dayOfWeekPerformance[dayName].weightedProfit += dayProfitToAdd;
                        dayOfWeekPerformance[dayName].days += 1;
                        dayOfWeekPerformance[dayName].avgPublisherCount += publisherCount;
                        
                        // Track publisher count effects
                        if (!publisherCountEffects[publisherCount]) {
                            publisherCountEffects[publisherCount] = {
                                totalRevenue: 0,
                                totalProfit: 0,
                                days: 0,
                                weightedRevenue: 0,
                                weightedProfit: 0
                            };
                        }
                        
                        // Use weighted or unweighted values based on temporal weighting setting
                        const countRevenueToAdd = this.temporalWeighting.enabled ? day.weightedRevenue : day.totalRevenue;
                        const countProfitToAdd = this.temporalWeighting.enabled ? day.weightedProfit : day.totalProfit;
                        
                        publisherCountEffects[publisherCount].totalRevenue += day.totalRevenue; // Keep unweighted for reference
                        publisherCountEffects[publisherCount].totalProfit += day.totalProfit; // Keep unweighted for reference
                        publisherCountEffects[publisherCount].weightedRevenue += countRevenueToAdd;
                        publisherCountEffects[publisherCount].weightedProfit += countProfitToAdd;
                        publisherCountEffects[publisherCount].days += 1;
                        
                        // Build global publisher performance from daily data
                        Object.keys(day.publisherData).forEach(publisher => {
                            if (!publisherPerformance[publisher]) {
                                publisherPerformance[publisher] = {
                                    totalRevenue: 0,
                                    totalProfit: 0,
                                    totalRecords: 0,
                                    activeDays: new Set(),
                                    verticals: new Set(),
                                    dailyProfits: [], // Track daily profits for accurate averaging
                                    totalIncoming: 0,
                                    totalConnected: 0,
                                    totalConverted: 0
                                };
                            }
                            
                            const pubData = day.publisherData[publisher];
                            publisherPerformance[publisher].totalRevenue += pubData.revenue;
                            publisherPerformance[publisher].totalProfit += pubData.profit;
                            publisherPerformance[publisher].totalRecords += pubData.records;
                            publisherPerformance[publisher].activeDays.add(day.date);
                            
                            // Add daily profit for this publisher on this day
                            publisherPerformance[publisher].dailyProfits.push(pubData.profit);
                            
                            // Track call volume metrics
                            publisherPerformance[publisher].totalIncoming += pubData.incoming;
                            publisherPerformance[publisher].totalConnected += pubData.connected;
                            publisherPerformance[publisher].totalConverted += pubData.converted;
                            
                            // Collect verticals
                            Array.from(pubData.verticals).forEach(v => {
                                publisherPerformance[publisher].verticals.add(v);
                            });
                        });
                        
                        return {
                            ...day,
                            buyerCount: publisherCount,
                            verticalCount: day.verticals.size,
                            verticals: Array.from(day.verticals),
                            avgMargin: Math.round(avgMargin * 100) / 100,
                            actualMargin: day.totalRevenue > 0 ? 
                                Math.round((day.totalProfit / day.totalRevenue) * 100 * 100) / 100 : 0,
                            recordCount: day.records.length,
                            publisherPerformance: Object.keys(day.publisherData).map(pub => ({
                                name: pub,
                                revenue: day.publisherData[pub].revenue,
                                profit: day.publisherData[pub].profit,
                                margin: day.publisherData[pub].revenue > 0 ? 
                                    (day.publisherData[pub].profit / day.publisherData[pub].revenue) * 100 : 0,
                                verticals: Array.from(day.publisherData[pub].verticals),
                                incoming: day.publisherData[pub].incoming,
                                connected: day.publisherData[pub].connected,
                                converted: day.publisherData[pub].converted,
                                connectRate: day.publisherData[pub].incoming > 0 ? 
                                    (day.publisherData[pub].connected / day.publisherData[pub].incoming) * 100 : 0,
                                conversionRate: day.publisherData[pub].connected > 0 ? 
                                    (day.publisherData[pub].converted / day.publisherData[pub].connected) * 100 : 0
                            }))
                        };
                    });
                
                // Finalize publisher performance calculations
                console.log('\n📈 Publisher Performance Calculations:');
                Object.keys(publisherPerformance).forEach(publisher => {
                    const perf = publisherPerformance[publisher];
                    perf.avgMargin = perf.totalRevenue > 0 ? (perf.totalProfit / perf.totalRevenue) * 100 : 0;
                    perf.activeDays = perf.activeDays.size;
                    perf.avgDailyRevenue = perf.activeDays > 0 ? perf.totalRevenue / perf.activeDays : 0;
                    perf.avgDailyProfit = perf.totalProfit / perf.activeDays;
                    perf.verticals = Array.from(perf.verticals);
                    
                    console.log(`${publisher}:`);
                    console.log(`  Total Profit: ${perf.totalProfit.toFixed(2)}`);
                    console.log(`  Active Days: ${perf.activeDays}`);
                    console.log(`  Avg Daily Profit: ${perf.avgDailyProfit.toFixed(2)}`);
                    console.log(`  Total Records: ${perf.totalRecords}`);
                });
                
                // Finalize day-of-week performance
                Object.keys(dayOfWeekPerformance).forEach(day => {
                    const perf = dayOfWeekPerformance[day];
                    
                    // Use weighted or unweighted values based on temporal weighting setting
                    if (this.temporalWeighting.enabled && perf.weightedRevenue > 0) {
                        perf.avgRevenue = perf.days > 0 ? perf.weightedRevenue / perf.days : 0;
                        perf.avgProfit = perf.days > 0 ? perf.weightedProfit / perf.days : 0;
                        perf.avgMargin = perf.weightedRevenue > 0 ? (perf.weightedProfit / perf.weightedRevenue) * 100 : 0;
                        console.log(`📊 ${day}: Using temporally weighted performance`);
                    } else {
                        perf.avgRevenue = perf.days > 0 ? perf.totalRevenue / perf.days : 0;
                        perf.avgProfit = perf.days > 0 ? perf.totalProfit / perf.days : 0;
                        perf.avgMargin = perf.totalRevenue > 0 ? (perf.totalProfit / perf.totalRevenue) * 100 : 0;
                        console.log(`📊 ${day}: Using unweighted performance`);
                    }
                    
                    perf.avgPublisherCount = perf.days > 0 ? perf.avgPublisherCount / perf.days : 0;
                });
                
                // Finalize publisher count effects
                Object.keys(publisherCountEffects).forEach(count => {
                    const perf = publisherCountEffects[count];
                    
                    // Use weighted or unweighted values based on temporal weighting setting
                    if (this.temporalWeighting.enabled && perf.weightedRevenue > 0) {
                        perf.avgRevenue = perf.days > 0 ? perf.weightedRevenue / perf.days : 0;
                        perf.avgProfit = perf.days > 0 ? perf.weightedProfit / perf.days : 0;
                        perf.avgMargin = perf.weightedRevenue > 0 ? (perf.weightedProfit / perf.weightedRevenue) * 100 : 0;
                        console.log(`📊 ${count} publishers: Using temporally weighted performance`);
                    } else {
                        perf.avgRevenue = perf.days > 0 ? perf.totalRevenue / perf.days : 0;
                        perf.avgProfit = perf.days > 0 ? perf.totalProfit / perf.days : 0;
                        perf.avgMargin = perf.totalRevenue > 0 ? (perf.totalProfit / perf.totalRevenue) * 100 : 0;
                        console.log(`📊 ${count} publishers: Using unweighted performance`);
                    }
                });
                
                // Store analytics
                this.publisherAnalytics = {
                    performanceByPublisher: publisherPerformance,
                    performanceByDay: dayOfWeekPerformance,
                    publisherCountEffects: publisherCountEffects,
                    topPerformers: this.calculateTopPerformers(publisherPerformance)
                };
                
                // Calculate maximum publishers from data
                const maxPublishersFromData = Math.max(...Object.keys(publisherCountEffects).map(count => parseInt(count)), 1);
                this.modelStats.maxPublishers = maxPublishersFromData;
                
                console.log(`📊 Analytics Summary:`);
                console.log(`• ${aggregatedDays.length} business days analyzed`);
                console.log(`• ${Object.keys(publisherPerformance).length} publishers tracked`);
                console.log(`• Maximum publishers in data: ${maxPublishersFromData}`);
                console.log(`• Top performers:`, Object.keys(publisherPerformance).slice(0, 3));
                
                return aggregatedDays;
            }
            
            calculateTopPerformers(publisherPerformance) {
                return Object.keys(publisherPerformance)
                    .map(publisher => {
                        const perf = publisherPerformance[publisher];
                        
                        // Calculate performance score based on multiple factors
                        let performanceScore = 0;
                        
                        // Factor 1: Daily profit (40% weight) - normalized to 0-40 scale
                        const dailyProfitScore = Math.min(40, Math.max(0, perf.avgDailyProfit / 100));
                        performanceScore += dailyProfitScore;
                        
                        // Factor 2: Margin (25% weight) - normalized to 0-25 scale
                        const marginScore = Math.min(25, Math.max(0, perf.avgMargin));
                        performanceScore += marginScore;
                        
                        // Factor 3: Call volume and conversion (20% weight) - if available
                        let volumeScore = 0;
                        if (perf.totalIncoming > 0) {
                            const avgDailyIncoming = perf.totalIncoming / perf.activeDays;
                            const connectRate = perf.totalIncoming > 0 ? (perf.totalConnected / perf.totalIncoming) * 100 : 0;
                            const conversionRate = perf.totalConnected > 0 ? (perf.totalConverted / perf.totalConnected) * 100 : 0;
                            
                            // Volume score based on daily incoming calls (scaled)
                            const incomingScore = Math.min(10, avgDailyIncoming / 10);
                            // Connect rate score (0-5 points)
                            const connectScore = Math.min(5, connectRate / 20);
                            // Conversion rate score (0-5 points) 
                            const conversionScore = Math.min(5, conversionRate / 20);
                            
                            volumeScore = incomingScore + connectScore + conversionScore;
                        } else {
                            // If no call volume data, give moderate score based on consistency
                            volumeScore = Math.min(15, perf.activeDays * 2);
                        }
                        performanceScore += volumeScore;
                        
                        // Factor 4: Consistency (15% weight) - based on active days
                        const consistencyScore = Math.min(15, perf.activeDays);
                        performanceScore += consistencyScore;
                        
                        // Add calculated metrics to the performance object
                        return {
                            name: publisher,
                            ...perf,
                            performanceScore: Math.round(performanceScore * 100) / 100,
                            avgDailyIncoming: perf.totalIncoming / perf.activeDays,
                            connectRate: perf.totalIncoming > 0 ? (perf.totalConnected / perf.totalIncoming) * 100 : 0,
                            conversionRate: perf.totalConnected > 0 ? (perf.totalConverted / perf.totalConnected) * 100 : 0
                        };
                    })
                    .filter(p => p.activeDays >= 2) // At least 2 active days
                    .sort((a, b) => b.performanceScore - a.performanceScore) // Sort by performance score
                    .slice(0, 10); // Top 10
            }
            
            calculateModelAccuracy(dailyAggregates) {
                if (!dailyAggregates || dailyAggregates.length === 0) {
                    return 75.0; // Default accuracy if no data
                }
                
                console.log(`🔍 Calculating accuracy for ${dailyAggregates.length} business days`);
                
                const predictions = [];
                
                dailyAggregates.forEach((day, index) => {
                    if (day.totalRevenue <= 0 || day.totalProfit === undefined || !day.verticals || day.verticals.length === 0) {
                        return;
                    }
                    
                    // Use the ACTUAL ML model prediction (no data leakage!)
                    const predictedMargin = this.predictMarginFromData(day.buyerCount, day.totalRevenue, day.verticals);
                    const predicted = day.totalRevenue * (predictedMargin / 100);
                    const actual = day.totalProfit;
                    
                    console.log(`Day ${index + 1}: Revenue=${day.totalRevenue.toFixed(0)}, Buyers=${day.buyerCount}, Verticals=${day.verticals.join(',')}`);
                    console.log(`  → Predicted Margin: ${predictedMargin.toFixed(2)}%, Predicted Profit: ${predicted.toFixed(0)}`);
                    console.log(`  → Actual Profit: ${actual.toFixed(0)}, Error: ${Math.abs(predicted - actual).toFixed(0)}`);
                    
                    // Only include valid predictions
                    if (predicted > 0 && actual !== 0 && !isNaN(predicted) && !isNaN(actual)) {
                        const absoluteError = Math.abs(predicted - actual);
                        const relativeError = absoluteError / Math.abs(actual);
                        
                        // Cap relative error at 300% to avoid extreme outliers
                        if (relativeError <= 3.0) {
                            const accuracy = Math.max(0, 1 - relativeError);
                            predictions.push({
                                predicted,
                                actual,
                                absoluteError,
                                relativeError,
                                accuracy
                            });
                            console.log(`  → Relative Error: ${(relativeError * 100).toFixed(1)}%, Accuracy: ${(accuracy * 100).toFixed(1)}%`);
                        } else {
                            console.log(`  → Excluded (error too high): ${(relativeError * 100).toFixed(1)}%`);
                        }
                    }
                });
                
                if (predictions.length === 0) {
                    console.log('⚠️ No valid predictions for accuracy calculation');
                    return 80.0; // Default accuracy if no valid predictions
                }
                
                // Calculate weighted accuracy
                const totalAccuracy = predictions.reduce((sum, pred) => sum + pred.accuracy, 0);
                const avgAccuracy = totalAccuracy / predictions.length;
                const finalAccuracy = Math.max(0, Math.min(100, avgAccuracy * 100));
                
                console.log(`📊 Final Accuracy: ${predictions.length} valid predictions, average accuracy: ${finalAccuracy.toFixed(1)}%`);
                
                return Math.round(finalAccuracy * 10) / 10; // Round to 1 decimal
            }
            
            calculateMAE(dailyAggregates) {
                if (!dailyAggregates || dailyAggregates.length === 0) {
                    return 0; // Default MAE if no data
                }
                
                console.log(`🔍 Calculating MAE for ${dailyAggregates.length} business days`);
                console.log(`📊 Current model coefficients:`, JSON.stringify(this.marginPredictionModel.verticalBaseMargins, null, 2));
                
                const errors = [];
                let validDays = 0;
                let skippedDays = 0;
                
                dailyAggregates.forEach((day, index) => {
                    if (day.totalRevenue <= 0 || day.totalProfit === undefined || !day.verticals || day.verticals.length === 0) {
                        skippedDays++;
                        console.log(`Day ${index + 1}: Skipped - Revenue: ${day.totalRevenue}, Profit: ${day.totalProfit}, Verticals: ${day.verticals ? day.verticals.length : 0}`);
                        return;
                    }
                    
                    // Use the ACTUAL ML model prediction
                    const predictedMargin = this.predictMarginFromData(day.buyerCount, day.totalRevenue, day.verticals);
                    const predicted = day.totalRevenue * (predictedMargin / 100);
                    const actual = day.totalProfit;
                    
                    // Only include valid predictions
                    if (predicted > 0 && actual !== 0 && !isNaN(predicted) && !isNaN(actual)) {
                        const absoluteError = Math.abs(predicted - actual);
                        errors.push(absoluteError);
                        validDays++;
                        
                        console.log(`Day ${index + 1}: Predicted=${predicted.toFixed(0)}, Actual=${actual.toFixed(0)}, Error=$${absoluteError.toFixed(0)}, Margin=${predictedMargin.toFixed(2)}%`);
                    } else {
                        skippedDays++;
                        console.log(`Day ${index + 1}: Invalid prediction - Predicted: ${predicted}, Actual: ${actual}`);
                    }
                });
                
                console.log(`📊 MAE Calculation Summary: ${validDays} valid predictions, ${skippedDays} skipped days`);
                
                if (errors.length === 0) {
                    console.log('⚠️ No valid predictions for MAE calculation');
                    return 0;
                }
                
                const mae = errors.reduce((sum, error) => sum + error, 0) / errors.length;
                console.log(`📊 MAE: $${mae.toFixed(0)} based on ${errors.length} predictions`);
                
                return Math.round(mae);
            }
            
            calculateConfidenceInterval(predictedProfit, mae, confidenceLevel = 0.95) {
                // Calculate confidence interval based on MAE and confidence level
                // Using a simplified approach: CI = predicted ± (MAE * z-score)
                const zScore = confidenceLevel === 0.95 ? 1.96 : confidenceLevel === 0.90 ? 1.645 : 1.96;
                const marginOfError = mae * zScore;
                
                const lowerBound = Math.max(0, predictedProfit - marginOfError);
                const upperBound = predictedProfit + marginOfError;
                
                console.log(`📊 Confidence Interval (${confidenceLevel * 100}%): $${lowerBound.toFixed(0)} - $${upperBound.toFixed(0)} (±$${marginOfError.toFixed(0)})`);
                
                return {
                    lowerBound: Math.round(lowerBound),
                    upperBound: Math.round(upperBound),
                    marginOfError: Math.round(marginOfError),
                    confidenceLevel: confidenceLevel
                };
            }
            
            updateModelCoefficients(dailyAggregates) {
                // Calculate overall statistics
                const totalRevenue = dailyAggregates.reduce((sum, day) => sum + day.totalRevenue, 0);
                const totalProfit = dailyAggregates.reduce((sum, day) => sum + day.totalProfit, 0);
                const overallMargin = totalRevenue > 0 ? (totalProfit / totalRevenue) * 100 : 0;
                
                // REMOVED: Revenue effects calculation - keeping all revenue effects neutral
                // this.marginPredictionModel.revenueMarginCurve.medRevenue = Math.max(0.8, Math.min(1.2, overallMargin / 25.0));
                
                // Recalculate vertical margins from actual training data
                const verticalData = {};
                
                // Process all individual records to get vertical-level data with temporal weighting
                this.trainingData.forEach(row => {
                    // STRENGTHENED: Skip weekend data using multiple checks
                    const dayName = (row.Day || '').toString().toLowerCase().trim();
                    if (dayName === 'saturday' || dayName === 'sunday' || 
                        dayName === 'sat' || dayName === 'sun' ||
                        dayName.startsWith('sat') || dayName.startsWith('sun')) {
                        return;
                    }
                    
                    // Also check using JavaScript Date object
                    try {
                        const dateObj = new Date(row.Date);
                        const dayOfWeek = dateObj.getDay(); // 0 = Sunday, 6 = Saturday
                        if (dayOfWeek === 0 || dayOfWeek === 6) {
                            return;
                        }
                    } catch (e) {
                        // Continue processing if date parsing fails
                    }
                    
                    // Skip rows with null/empty margin values
                    const margin = parseFloat(row.Margin);
                    if (isNaN(margin) || row.Margin === null || row.Margin === undefined || row.Margin === '') {
                        return;
                    }
                    
                    const vertical = row.Vertical;
                    const revenue = parseFloat(row.Revenue) || 0;
                    const netProfit = parseFloat(row['Net Profit']) || 0;
                    
                    if (revenue > 0 && vertical && vertical.trim() !== '') {
                        if (!verticalData[vertical]) {
                            verticalData[vertical] = {
                                totalRevenue: 0,
                                totalProfit: 0,
                                recordCount: 0,
                                weightedRevenue: 0,
                                weightedProfit: 0
                            };
                        }
                        
                        // Apply temporal weighting if enabled
                        const temporalWeight = this.calculateTemporalWeight(row.Date);
                        
                        verticalData[vertical].totalRevenue += revenue;
                        verticalData[vertical].totalProfit += netProfit;
                        verticalData[vertical].recordCount += 1;
                        verticalData[vertical].weightedRevenue += revenue * temporalWeight;
                        verticalData[vertical].weightedProfit += netProfit * temporalWeight;
                    }
                });
                
                // Calculate and update actual margins for each vertical
                Object.keys(verticalData).forEach(vertical => {
                    const data = verticalData[vertical];
                    if (data.totalRevenue > 0 && data.recordCount >= 2) {
                        let aggregateMargin;
                        
                        if (this.temporalWeighting.enabled && data.weightedRevenue > 0) {
                            // Use temporally weighted margins when enabled
                            aggregateMargin = data.weightedProfit / data.weightedRevenue;
                            console.log(`📊 ${vertical}: Using temporally weighted margin (${(aggregateMargin * 100).toFixed(2)}%)`);
                        } else {
                            // Use unweighted margins when temporal weighting is disabled
                            aggregateMargin = data.totalProfit / data.totalRevenue;
                            console.log(`📊 ${vertical}: Using unweighted margin (${(aggregateMargin * 100).toFixed(2)}%)`);
                        }
                        
                        const cappedMargin = Math.max(-0.5, Math.min(0.8, aggregateMargin));
                        this.marginPredictionModel.verticalBaseMargins[vertical] = cappedMargin;
                    }
                });
                
                // ENSURE revenue effects stay neutral after retraining
                this.marginPredictionModel.revenueMarginCurve = {
                    lowRevenue: 1.0,
                    medRevenue: 1.0,
                    highRevenue: 1.0,
                    enterpriseRevenue: 1.0
                };
                
                console.log(`✅ Model coefficients updated - Revenue effects kept neutral`);
                console.log(`🕒 Temporal weighting: ${this.temporalWeighting.enabled ? 'ENABLED' : 'DISABLED'}`);
                if (this.temporalWeighting.enabled) {
                    console.log(`   Method: ${this.temporalWeighting.method}, Decay rate: ${this.temporalWeighting.decayRate}`);
                    console.log(`   Reference date: ${this.temporalWeighting.referenceDate ? this.temporalWeighting.referenceDate.toISOString().split('T')[0] : 'Not set'}`);
                }
                
                // Update vertical display values for UI
                this.updateVerticalDisplayMargins();
                
                // Update publisher input field max value
                this.updatePublisherInputMax();
                
                // Update warning display with correct max value
                if (typeof checkPublisherWarning === 'function') {
                    checkPublisherWarning();
                }
            }
            
            updatePublisherInputMax() {
                const maxPublishers = this.modelStats.maxPublishers || 20;
                const publisherInput = document.getElementById('num_media_buyers');
                if (publisherInput) {
                    // Remove the max attribute to allow JavaScript validation to work properly
                    publisherInput.removeAttribute('max');
                    console.log(`📊 Removed max attribute from publisher input (max from data: ${maxPublishers})`);
                }
            }
            
            updateVerticalDisplayMargins() {
                // Update the UI to show actual calculated margins
                const verticalElements = {
                    'MEDICARE ENGLISH': 'vertical_medicare_en',
                    'FINAL EXPENSE ENGLISH': 'vertical_final_expense', 
                    'ACA ENGLISH': 'vertical_aca',
                    'MEDICARE SPANISH': 'vertical_medicare_es',
                    'AUTO INSURANCE ENGLISH': 'vertical_auto'
                };
                
                Object.keys(verticalElements).forEach(vertical => {
                    const elementId = verticalElements[vertical];
                    const element = document.getElementById(elementId);
                    if (element) {
                        const marginValue = this.marginPredictionModel.verticalBaseMargins[vertical];
                        const statsElement = element.closest('.vertical-option').querySelector('.vertical-stats');
                        
                        if (statsElement) {
                            if (marginValue !== undefined) {
                                const margin = marginValue * 100;
                                let marginText, performance, badgeClass;
                                
                                if (margin === 0) {
                                    marginText = '0.0% (No Data)';
                                    performance = 'No revenue data';
                                    badgeClass = 'badge-secondary';
                                } else if (margin < 0) {
                                    marginText = `${margin.toFixed(1)}% (Loss)`;
                                    performance = 'Loss-making';
                                    badgeClass = 'badge-secondary';
                                } else if (margin > 25) {
                                    marginText = `${margin.toFixed(1)}%`;
                                    performance = 'Top performer';
                                    badgeClass = 'badge-success';
                                } else if (margin > 15) {
                                    marginText = `${margin.toFixed(1)}%`;
                                    performance = 'Solid performer';
                                    badgeClass = 'badge-primary';
                                } else {
                                    marginText = `${margin.toFixed(1)}%`;
                                    performance = 'Moderate performer';
                                    badgeClass = 'badge-warning';
                                }
                                
                                statsElement.textContent = `Historical Margin: ${marginText} • ${performance}`;
                                
                                // Update badge class if it exists
                                const badgeElement = element.closest('.vertical-option').querySelector('.vertical-badge');
                                if (badgeElement && badgeClass) {
                                    // Remove existing badge classes
                                    badgeElement.classList.remove('badge-success', 'badge-primary', 'badge-info', 'badge-warning', 'badge-secondary');
                                    badgeElement.classList.add(badgeClass);
                                    
                                    // Update badge text based on performance
                                    if (margin === 0) {
                                        badgeElement.textContent = 'No Data';
                                    } else if (margin < 0) {
                                        badgeElement.textContent = 'Loss Making';
                                    }
                                }
                                
                            } else {
                                // Fallback to default values
                                statsElement.textContent = `Historical Margin: Default • Estimated`;
                            }
                        }
                    }
                });
            }
            
            updateModelStatusDisplay() {
                try {
                    const trainingRecords = this.modelStats.totalRecords || 402;
                    const lastUpdated = this.modelStats.lastUpdated || 'Initial data';
                    const accuracy = this.modelStats.accuracy || 87.3;
                    const avgRevenue = this.modelStats.avgDailyRevenue || 18481;
                    const avgProfit = this.modelStats.avgDailyProfit || 3940;
                    const mae = this.modelStats.mae || 1250;
                    
                    // FIXED: Update all model status elements including average daily revenue
                    const trainingRecordsEl = document.getElementById('training-records');
                    const lastUpdatedEl = document.getElementById('last-updated');
                    const modelAccuracyEl = document.getElementById('model-accuracy');
                    const avgDailyRevenueEl = document.getElementById('avg-daily-revenue');
                    const avgDailyProfitEl = document.getElementById('avg-daily-profit');
                    const modelMaeEl = document.getElementById('model-mae');
                    
                    if (trainingRecordsEl) trainingRecordsEl.textContent = trainingRecords.toLocaleString();
                    if (lastUpdatedEl) lastUpdatedEl.textContent = lastUpdated;
                    if (modelAccuracyEl) modelAccuracyEl.textContent = `${accuracy}%`;
                    if (avgDailyRevenueEl) avgDailyRevenueEl.textContent = `${avgRevenue.toLocaleString()}`;
                    if (avgDailyProfitEl) avgDailyProfitEl.textContent = `${avgProfit.toLocaleString()}`;
                    if (modelMaeEl) modelMaeEl.textContent = `$${mae.toLocaleString()}`;
                    
                    console.log('✅ Model status display updated:', {
                        records: trainingRecords,
                        revenue: avgRevenue,
                        profit: avgProfit,
                        accuracy: accuracy
                    });
                } catch (error) {
                    console.error('Error updating model status display:', error);
                }
            }
        }
        
        // Initialize system
        const predictor = new DailyProfitPredictor();
        
        // Global functions
        function showAlert(message, type = 'info') {
            const alertContainer = document.getElementById('alert-container');
            const alertHTML = `
                <div class="alert alert-${type} fade-in">
                    ${message}
                </div>
            `;
            alertContainer.innerHTML = alertHTML;
            
            setTimeout(() => {
                const alert = alertContainer.querySelector('.alert');
                if (alert) {
                    alert.style.opacity = '0';
                    alert.style.transform = 'translateY(-10px)';
                    setTimeout(() => alertContainer.innerHTML = '', 300);
                }
            }, 5000);
        }
        
        function showHowItWorks() {
            const modal = document.getElementById('how-it-works-modal');
            modal.style.display = 'flex';
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
        }
        
        function hideHowItWorks() {
            const modal = document.getElementById('how-it-works-modal');
            modal.classList.remove('show');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const howItWorksModal = document.getElementById('how-it-works-modal');
            const retrainModal = document.getElementById('retrain-success-modal');
            
            if (event.target === howItWorksModal) {
                hideHowItWorks();
            }
            if (event.target === retrainModal) {
                hideRetrainSuccess();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                hideHowItWorks();
                hideRetrainSuccess();
            }
        });
        
        function toggleDebugPanel() {
            const debugPanel = document.getElementById('debug-panel');
            const debugToggleBtn = document.getElementById('debug-toggle');
            const isExpanded = debugPanel.classList.contains('expanded');
            
            if (isExpanded) {
                // Collapse the panel
                debugPanel.classList.remove('expanded');
                debugPanel.classList.add('collapsed');
                debugToggleBtn.innerHTML = '<i class="fas fa-bug me-1"></i> Show Debug';
                debugToggleBtn.classList.remove('debug-active');
            } else {
                // Expand the panel
                debugPanel.classList.remove('collapsed');
                debugPanel.classList.add('expanded');
                debugToggleBtn.innerHTML = '<i class="fas fa-bug me-1"></i> Hide Debug';
                debugToggleBtn.classList.add('debug-active');
                
                // Update debug info when panel is opened
                setTimeout(() => {
                    predictor.updateDebugInfo();
                }, 100);
            }
            
            // Store preference in memory (since localStorage is not available)
            window.debugPanelVisible = !isExpanded;
        }
        
        function updateDebugInfo() {
            predictor.updateDebugInfo();
        }
        
        function handleVerticalChange(event) {
            const checkbox = event.target;
            const option = checkbox.closest('.vertical-option');
            
            if (checkbox.checked) {
                option.classList.add('selected');
            } else {
                option.classList.remove('selected');
            }
            
            // Update debug info when verticals change
            updateDebugInfo();
        }
        
        function checkPublisherWarning() {
            const numBuyers = parseInt(document.getElementById('num_media_buyers').value);
            
            // Get the most accurate maxPublishers value
            let maxPublishers = 20; // Default fallback
            
            if (predictor && predictor.modelStats && predictor.modelStats.maxPublishers) {
                maxPublishers = predictor.modelStats.maxPublishers;
            } else if (predictor && predictor.publisherAnalytics && predictor.publisherAnalytics.publisherCountEffects) {
                // Calculate from actual data if modelStats not available
                const publisherCounts = Object.keys(predictor.publisherAnalytics.publisherCountEffects)
                    .map(count => parseInt(count))
                    .filter(count => !isNaN(count));
                if (publisherCounts.length > 0) {
                    maxPublishers = Math.max(...publisherCounts);
                }
            }
            
            console.log(`🔍 Publisher warning check: entered=${numBuyers}, maxFromData=${maxPublishers}`);
            console.log(`🔍 Model stats:`, predictor.modelStats);
            console.log(`🔍 Publisher analytics:`, predictor.publisherAnalytics?.publisherCountEffects);
            
            // Remove any existing warning
            const existingWarning = document.getElementById('publisher-warning');
            if (existingWarning) {
                existingWarning.remove();
            }
            
            // Show warning if publisher count exceeds training data
            if (numBuyers > maxPublishers && numBuyers > 0) {
                const warningDiv = document.createElement('div');
                warningDiv.id = 'publisher-warning';
                warningDiv.className = 'alert alert-warning fade-in';
                warningDiv.style.marginTop = '8px';
                warningDiv.innerHTML = `
                    <i class="fas fa-exclamation-triangle" style="margin-right: 6px;"></i>
                    You entered ${numBuyers} publishers, but your training data only contains up to ${maxPublishers} publishers. 
                    Predictions may be less accurate for publisher counts outside your historical data range.
                `;
                
                const publisherInput = document.getElementById('num_media_buyers');
                publisherInput.parentNode.appendChild(warningDiv);
            }
        }
        
        function validateForm() {
            const numBuyers = parseInt(document.getElementById('num_media_buyers').value);
            const targetRevenue = parseFloat(document.getElementById('target_revenue').value);
            const selectedVerticals = predictor.getSelectedVerticals();
            
            const errors = [];
            const warnings = [];
            
            // Get the most accurate maxPublishers value
            let maxPublishers = 20; // Default fallback
            
            if (predictor && predictor.modelStats && predictor.modelStats.maxPublishers) {
                maxPublishers = predictor.modelStats.maxPublishers;
            } else if (predictor && predictor.publisherAnalytics && predictor.publisherAnalytics.publisherCountEffects) {
                // Calculate from actual data if modelStats not available
                const publisherCounts = Object.keys(predictor.publisherAnalytics.publisherCountEffects)
                    .map(count => parseInt(count))
                    .filter(count => !isNaN(count));
                if (publisherCounts.length > 0) {
                    maxPublishers = Math.max(...publisherCounts);
                }
            }
            if (!numBuyers || numBuyers < 1) {
                errors.push('Number of affiliate publishers must be at least 1');
            } else if (numBuyers > maxPublishers) {
                warnings.push(`⚠️ You entered ${numBuyers} publishers, but your training data only contains up to ${maxPublishers} publishers. Predictions may be less accurate for publisher counts outside your historical data range.`);
            }
            
            if (!targetRevenue || targetRevenue < 1000) {
                errors.push('Total daily revenue must be at least $1,000');
            }
            
            if (selectedVerticals.length === 0) {
                errors.push('Please select at least one vertical');
            } else {
                // Check for verticals with no data
                const zeroMarginVerticals = selectedVerticals.filter(vertical => {
                    const margin = predictor.marginPredictionModel.verticalBaseMargins[vertical];
                    return margin === 0 || margin === undefined;
                });
                
                if (zeroMarginVerticals.length > 0) {
                    warnings.push(`Warning: ${zeroMarginVerticals.join(', ')} has no profitable historical data and will be excluded from calculations`);
                }
                
                // Check if ALL selected verticals have zero margin
                const validVerticals = selectedVerticals.filter(vertical => {
                    const margin = predictor.marginPredictionModel.verticalBaseMargins[vertical];
                    return margin && margin > 0;
                });
                
                if (validVerticals.length === 0) {
                    errors.push('All selected verticals have 0% margin. Please select verticals with historical revenue data.');
                }
            }
            
            return { errors, warnings };
        }
        
        function generatePrediction() {
            document.getElementById('alert-container').innerHTML = '';
            
            const validation = validateForm();
            
            // Show errors first
            if (validation.errors.length > 0) {
                showAlert(`Please fix the following:<br>• ${validation.errors.join('<br>• ')}`, 'danger');
                return;
            }
            
            // Show warnings but continue
            if (validation.warnings.length > 0) {
                showAlert(`⚠️ ${validation.warnings.join('<br>• ')}`, 'warning');
            }
            
            const numBuyers = parseInt(document.getElementById('num_media_buyers').value);
            const targetRevenue = parseFloat(document.getElementById('target_revenue').value);
            const selectedVerticals = predictor.getSelectedVerticals();
            
            console.log('Generating prediction with:', { numBuyers, targetRevenue, selectedVerticals });
            
            const predictionData = predictor.calculateDailyProfit(numBuyers, targetRevenue, selectedVerticals);
            
            if (!predictionData) {
                showAlert('Unable to calculate prediction. Please check your inputs.', 'danger');
                return;
            }
            
            console.log('Prediction result:', predictionData);
            
            const insights = predictor.generateInsights(predictionData, numBuyers, targetRevenue, predictionData.predictedMargin);
            displayResults(numBuyers, targetRevenue, predictionData.predictedMargin, selectedVerticals, predictionData, insights);
        }
        
        function displayResults(numBuyers, targetRevenue, expectedMargin, selectedVerticals, predictionData, insights) {
            console.log('📊 Displaying results with insights:', insights);
            
            const isProfitable = predictionData.predictedProfit >= 0;
            
            const resultsHTML = `
                <div class="result-card fade-in">
                    <div class="result-header">
                        <div class="profit-display ${isProfitable ? 'profit-positive' : 'profit-negative'}">
                            ${isProfitable ? '+' : ''}${Math.abs(predictionData.predictedProfit).toLocaleString('en-US', {minimumFractionDigits: 2})}
                        </div>
                        <div class="profit-label">Predicted Daily Net ${isProfitable ? 'Profit' : 'Loss'} (All Affiliate Publishers)</div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-value" style="color: #059669;">${predictionData.expectedRevenue.toLocaleString()}</div>
                            <div class="metric-label">Expected Revenue</div>
                            <div class="metric-subtitle">Total from all affiliates</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" style="color: #0ea5e9;">${predictionData.predictedMargin}%</div>
                            <div class="metric-label">Your Margin</div>
                            <div class="metric-subtitle">Your cut of revenue</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" style="color: #f59e0b;">${predictionData.publisherPayout.toLocaleString()}</div>
                            <div class="metric-label">Publisher Payout</div>
                            <div class="metric-subtitle">${predictionData.publisherMargin}% to affiliates</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" style="color: #8b5cf6;">${numBuyers}</div>
                            <div class="metric-label">Active Affiliates</div>
                            <div class="metric-subtitle">Affiliate publishers today</div>
                        </div>
                    </div>
                    
                    <!-- MAE and Confidence Interval Section -->
                    <div style="background: #f8fafc; border-radius: 8px; padding: 20px; margin: 24px 0; border: 1px solid #e2e8f0;">
                        <h3 style="font-size: 16px; font-weight: 600; color: #1e293b; margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                            <i class="fas fa-chart-line" style="color: #3b82f6;"></i>
                            Prediction Accuracy & Confidence
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;" class="mae-confidence-grid">
                            <!-- MAE Card -->
                            <div style="background: white; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <i class="fas fa-exclamation-triangle" style="color: #f59e0b;"></i>
                                    <span style="font-size: 14px; font-weight: 600; color: #374151;">Mean Absolute Error</span>
                                </div>
                                <div style="font-size: 24px; font-weight: 700; color: #dc2626; margin-bottom: 4px;">
                                    $${predictionData.mae.toLocaleString()}
                                </div>
                                <div style="font-size: 12px; color: #6b7280;">
                                    Average prediction error in dollar amounts
                                </div>
                            </div>
                            
                            <!-- Confidence Interval Card -->
                            <div style="background: white; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                    <i class="fas fa-shield-alt" style="color: #059669;"></i>
                                    <span style="font-size: 14px; font-weight: 600; color: #374151;">95% Confidence Interval</span>
                                </div>
                                <div style="font-size: 18px; font-weight: 600; color: #059669; margin-bottom: 4px;">
                                    $${predictionData.confidenceInterval.lowerBound.toLocaleString()} - $${predictionData.confidenceInterval.upperBound.toLocaleString()}
                                </div>
                                <div style="font-size: 12px; color: #6b7280;">
                                    ±$${predictionData.confidenceInterval.marginOfError.toLocaleString()} margin of error
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 16px; padding: 12px; background: #eff6ff; border-radius: 6px; border-left: 4px solid #3b82f6;">
                            <div style="font-size: 13px; color: #1e40af; line-height: 1.5;">
                                <strong>Interpretation:</strong> We predict a profit of $${predictionData.predictedProfit.toLocaleString()} ± $${predictionData.confidenceInterval.marginOfError.toLocaleString()} (95% confidence). 
                                This means the actual profit will likely fall between $${predictionData.confidenceInterval.lowerBound.toLocaleString()} and $${predictionData.confidenceInterval.upperBound.toLocaleString()}.
                            </div>
                        </div>
                    </div>
                    
                    <div class="insights-section">
                        <h3 class="insights-title">Performance Insights</h3>
                        ${insights.map(insight => `
                            <div class="insight-item">
                                <div class="insight-icon">${insight.icon}</div>
                                <div class="insight-content">
                                    <span class="insight-category">${insight.category}:</span>
                                    ${insight.text}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="actions">
                        <button class="btn-secondary" onclick="scrollToForm()">
                            <i class="fas fa-edit me-1"></i>
                            Modify Parameters
                        </button>
                        <button class="btn-secondary" onclick="showAnalytics()">
                            <i class="fas fa-chart-bar me-1"></i>
                            View Analytics
                        </button>
                        <button class="btn-secondary" onclick="window.print()">
                            <i class="fas fa-download me-1"></i>
                            Export Results
                        </button>
                    </div>
                    

                </div>
                
                ${generateAnalyticsSection()}
            `;
            
            const resultsSection = document.getElementById('results-section');
            const resultsContainer = document.getElementById('prediction-results');
            
            resultsContainer.innerHTML = resultsHTML;
            resultsSection.style.display = 'block';
            
            setTimeout(() => {
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                const profitDisplay = document.querySelector('.profit-display');
                if (profitDisplay) {
                    profitDisplay.classList.add('pulse');
                }
            }, 100);
        }
        
        function generateAnalyticsSection() {
            if (!predictor.publisherAnalytics || !predictor.trainingData.length) {
                console.log('❌ No analytics available - publisherAnalytics:', predictor.publisherAnalytics, 'trainingData length:', predictor.trainingData.length);
                return '';
            }
            
            const analytics = predictor.publisherAnalytics;
            console.log('🔍 Generating analytics section with:', {
                topPerformers: analytics.topPerformers?.length || 0,
                performanceByDay: Object.keys(analytics.performanceByDay || {}).length,
                publisherCountEffects: Object.keys(analytics.publisherCountEffects || {}).length,
                performanceByPublisher: Object.keys(analytics.performanceByPublisher || {}).length
            });
            
            // Publisher performance table
            let publisherTable = '';
            if (analytics.topPerformers && analytics.topPerformers.length > 0) {
                const hasCallData = analytics.topPerformers.some(p => p.avgDailyIncoming > 0);
                const totalPublishers = Object.keys(analytics.performanceByPublisher || {}).length;
                
                publisherTable = `
                    <div class="analytics-section" style="margin-top: 24px;">
                        <h3 class="insights-title">📊 Top Publisher Performance</h3>
                        <div style="margin-bottom: 12px; font-size: 13px; color: #6b7280;">
                            Showing top ${Math.min(analytics.topPerformers.length, 10)} of ${totalPublishers} total publishers
                        </div>
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                                <thead>
                                    <tr style="background: #f8fafc; text-align: left;">
                                        <th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Publisher</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Score</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Margin</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Daily Profit</th>
                                        <th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Active Days</th>
                                        ${hasCallData ? '<th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Daily Calls</th>' : ''}
                                        ${hasCallData ? '<th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Connect%</th>' : ''}
                                        <th style="padding: 8px; border-bottom: 1px solid #e2e8f0;">Verticals</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${analytics.topPerformers.slice(0, 10).map(pub => `
                                        <tr>
                                            <td style="padding: 8px; border-bottom: 1px solid #f1f5f9; font-weight: 500;">${pub.name}</td>
                                            <td style="padding: 8px; border-bottom: 1px solid #f1f5f9; color: ${pub.performanceScore > 60 ? '#059669' : pub.performanceScore > 40 ? '#f59e0b' : '#dc2626'}; font-weight: 600;">${pub.performanceScore.toFixed(1)}</td>
                                            <td style="padding: 8px; border-bottom: 1px solid #f1f5f9; color: ${pub.avgMargin > 20 ? '#059669' : '#f59e0b'};">${pub.avgMargin.toFixed(1)}%</td>
                                            <td style="padding: 8px; border-bottom: 1px solid #f1f5f9;">${pub.avgDailyProfit.toFixed(0)}</td>
                                            <td style="padding: 8px; border-bottom: 1px solid #f1f5f9;">${pub.activeDays}</td>
                                            ${hasCallData ? `<td style="padding: 8px; border-bottom: 1px solid #f1f5f9;">${pub.avgDailyIncoming > 0 ? pub.avgDailyIncoming.toFixed(0) : 'N/A'}</td>` : ''}
                                            ${hasCallData ? `<td style="padding: 8px; border-bottom: 1px solid #f1f5f9;">${pub.connectRate > 0 ? pub.connectRate.toFixed(1) + '%' : 'N/A'}</td>` : ''}
                                            <td style="padding: 8px; border-bottom: 1px solid #f1f5f9; font-size: 11px;">${pub.verticals.slice(0, 2).join(', ')}${pub.verticals.length > 2 ? '...' : ''}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        <div style="margin-top: 8px; font-size: 11px; color: #6b7280;">
                            ${hasCallData ? 'Performance Score: Daily Profit (40%) + Margin (25%) + Call Volume & Conversion (20%) + Consistency (15%)' : 'Performance Score: Daily Profit (40%) + Margin (25%) + Consistency (35%)'}
                        </div>
                    </div>
                `;
            }
            
            // Day of week performance
            let dayTable = '';
            if (analytics.performanceByDay && Object.keys(analytics.performanceByDay).length > 0) {
                const sortedDays = Object.keys(analytics.performanceByDay)
                    .map(day => ({ day, ...analytics.performanceByDay[day] }))
                    .filter(d => d.days >= 1)
                    .sort((a, b) => b.avgMargin - a.avgMargin);
                
                dayTable = `
                    <div class="analytics-section" style="margin-top: 24px;">
                        <h3 class="insights-title">📅 Day-of-Week Performance</h3>
                        <div class="metrics-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
                            ${sortedDays.map(day => `
                                <div class="metric-card">
                                    <div class="metric-value" style="color: ${day.avgMargin > 20 ? '#059669' : '#f59e0b'};">${day.avgMargin.toFixed(1)}%</div>
                                    <div class="metric-label">${day.day}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Publisher count effects
            let countTable = '';
            if (analytics.publisherCountEffects && Object.keys(analytics.publisherCountEffects).length > 1) {
                const sortedCounts = Object.keys(analytics.publisherCountEffects)
                    .map(count => ({ count: parseInt(count), ...analytics.publisherCountEffects[count] }))
                    .filter(c => c.days >= 1)
                    .sort((a, b) => a.count - b.count);
                
                countTable = `
                    <div class="analytics-section" style="margin-top: 24px;">
                        <h3 class="insights-title">👥 Publisher Count Impact</h3>
                        <div class="metrics-grid" style="grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));">
                            ${sortedCounts.map(count => `
                                <div class="metric-card">
                                    <div class="metric-value" style="color: ${count.avgMargin > 20 ? '#059669' : '#f59e0b'};">${count.avgMargin.toFixed(1)}%</div>
                                    <div class="metric-label">${count.count} Publishers</div>
                                    <div class="metric-subtitle">${count.days} days data</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            return `
                <div id="analytics-details" style="display: none;">
                    ${publisherTable}
                    ${dayTable}
                    ${countTable}
                </div>
            `;
        }
        
        function showAnalytics() {
            const analyticsDiv = document.getElementById('analytics-details');
            if (analyticsDiv) {
                if (analyticsDiv.style.display === 'none') {
                    analyticsDiv.style.display = 'block';
                    analyticsDiv.classList.add('fade-in');
                    setTimeout(() => {
                        analyticsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 100);
                } else {
                    analyticsDiv.style.display = 'none';
                }
            } else {
                showAlert('Upload training data first to see detailed analytics.', 'info');
            }
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file && file.name.endsWith('.csv')) {
                predictor.processCSVFile(file);
            } else {
                showAlert('Please select a valid CSV file', 'danger');
            }
        }
        
        function scrollToForm() {
            document.getElementById('prediction-form').scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
        }
        
        function resetForm() {
            // Store current training data and analytics before reset
            const currentTrainingData = predictor.trainingData;
            const currentAnalytics = predictor.publisherAnalytics;
            const hasUploadedData = currentTrainingData && currentTrainingData.length > 0;
            
            document.getElementById('prediction-form').reset();
            document.querySelectorAll('.vertical-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.getElementById('results-section').style.display = 'none';
            document.getElementById('alert-container').innerHTML = '';
            
            // Reset defaults
            document.getElementById('num_media_buyers').value = 5;
            document.getElementById('target_revenue').value = 25000;
            predictor.setDefaults();
            
            // Restore training data and analytics if they existed
            if (hasUploadedData) {
                predictor.trainingData = currentTrainingData;
                predictor.publisherAnalytics = currentAnalytics;
                
                // Keep the upload area showing success state
                const uploadArea = document.getElementById('upload-area');
                uploadArea.innerHTML = `
                    <div class="upload-icon" style="color: #22c55e;">
                        <i class="fas fa-check-circle"></i>
                    </div>
                    <div class="upload-text" style="color: #22c55e;">CSV file loaded successfully!</div>
                    <div class="upload-subtext">${currentTrainingData.length} valid records ready for training</div>
                    <input type="file" id="csv-upload" accept=".csv" style="display: none;" onchange="handleFileUpload(event)">
                `;
                uploadArea.style.borderColor = '#22c55e';
                uploadArea.style.background = '#f0fdf4';
                
                // Re-attach the click handler after updating innerHTML
                uploadArea.onclick = function() {
                    document.getElementById('csv-upload').click();
                };
                
                // Keep retrain button visible
                document.getElementById('retrain-button').style.display = 'block';
                
                showAlert('Form reset to default values. Your uploaded CSV data and analytics are preserved.', 'success');
            } else {
                // Reset upload area to original state only if no data was uploaded
                resetUploadArea();
                showAlert('Form has been reset to default values.', 'info');
            }
            
            // Only update debug if panel is visible
            if (window.debugPanelVisible) {
                updateDebugInfo();
            }
        }
        
        function resetUploadArea() {
            const uploadArea = document.getElementById('upload-area');
            uploadArea.innerHTML = `
                <div class="upload-icon">
                    <i class="fas fa-cloud-upload-alt"></i>
                </div>
                <div class="upload-text">Click to upload CSV file</div>
                <div class="upload-subtext">Or drag and drop your training data</div>
                <input type="file" id="csv-upload" accept=".csv" style="display: none;" onchange="handleFileUpload(event)">
            `;
            uploadArea.style.borderColor = '#d1d5db';
            uploadArea.style.background = '';
            
            // Re-attach ALL event handlers after updating innerHTML
            uploadArea.onclick = function() {
                document.getElementById('csv-upload').click();
            };
            
            // Re-attach drag and drop handlers
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].name.endsWith('.csv')) {
                    predictor.processCSVFile(files[0]);
                }
            });
        }
        
        function clearAllData() {
            console.log('🗑️ Clearing all data...');
            
            // Clear all training data and analytics
            predictor.trainingData = [];
            predictor.publisherAnalytics = {
                performanceByPublisher: {},
                performanceByDay: {},
                publisherCountEffects: {},
                topPerformers: []
            };
            
            // Reset upload area completely
            resetUploadArea();
            
            // Hide retrain and clear data buttons
            document.getElementById('retrain-button').style.display = 'none';
            document.getElementById('clear-data-btn').style.display = 'none';
            
            // Hide results section
            document.getElementById('results-section').style.display = 'none';
            
            // Reset model status to defaults
            predictor.modelStats = {
                totalRecords: 402,
                avgDailyRevenue: 18481,
                avgDailyProfit: 3940,
                accuracy: 87.3,
                mae: 1250,
                lastUpdated: 'Initial data'
            };
            
            // Reset vertical margins to defaults
            predictor.marginPredictionModel.verticalBaseMargins = {
                'MEDICARE ENGLISH': 0.213,
                'FINAL EXPENSE ENGLISH': 0.216,
                'ACA ENGLISH': 0.244,
                'MEDICARE SPANISH': 0.245,
                'AUTO INSURANCE ENGLISH': 0.0
            };
            
            // Reset revenue effects to neutral (no penalties)
            predictor.marginPredictionModel.revenueMarginCurve = {
                lowRevenue: 1.0,
                medRevenue: 1.0,
                highRevenue: 1.0,
                enterpriseRevenue: 1.0
            };
            
            predictor.updateVerticalDisplayMargins();
            
            // Force update model status display
            predictor.updateModelStatusDisplay();
            
            showAlert('All uploaded data and analytics have been cleared. System reset to defaults.', 'info');
        }
        
        function retrainModel() {
            predictor.retrainModel();
        }
        
        function showRetrainSuccess() {
            const modal = document.getElementById('retrain-success-modal');
            modal.style.display = 'flex';
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
        }
        
        function hideRetrainSuccess() {
            const modal = document.getElementById('retrain-success-modal');
            modal.classList.remove('show');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
        }
        
        function toggleTemporalWeightingFromPanel() {
            // Get checkbox state
            const checkbox = document.getElementById('temporal-checkbox');
            const isEnabled = checkbox.checked;
            
            // Update predictor setting
            predictor.temporalWeighting.enabled = isEnabled;
            
            // Update status text and nav button
            updateTemporalWeightingUI();
            
            // Show notification
            if (isEnabled) {
                showAlert('✅ Temporal weighting enabled. Recent data will be weighted higher in predictions.', 'success');
            } else {
                showAlert('⚠️ Temporal weighting disabled. All data will be weighted equally in predictions.', 'warning');
            }
            
            // Update debug info if panel is visible
            if (window.debugPanelVisible) {
                updateDebugInfo();
            }
            
            console.log('🕒 Temporal weighting toggled from panel:', isEnabled ? 'ENABLED' : 'DISABLED');
        }
        
        function updateTemporalWeightingUI() {
            const isEnabled = predictor.temporalWeighting.enabled;
            
            // Update panel toggle
            const checkbox = document.getElementById('temporal-checkbox');
            if (checkbox) checkbox.checked = isEnabled;
            
            // Update panel status text
            const statusEl = document.getElementById('temporal-weighting-status');
            if (statusEl) {
                statusEl.textContent = isEnabled ? 'Enabled' : 'Disabled';
                statusEl.style.color = isEnabled ? '#059669' : '#dc2626';
            }
        }
        
        // Test function to validate all changes (FIXED)
        function validateSystem() {
            console.log('🧪 SYSTEM VALIDATION TEST');
            console.log('========================');
            
            // Test 1: Check model stats
            console.log('1. Model Stats:', predictor.modelStats);
            
            // Test 2: Check if revenue element exists
            const revenueElement = document.getElementById('avg-daily-revenue');
            console.log('2. Revenue element exists:', !!revenueElement, revenueElement?.textContent);
            
            // Test 3: Check all model status elements
            const statusElements = ['training-records', 'last-updated', 'model-accuracy', 'avg-daily-revenue', 'avg-daily-profit'];
            statusElements.forEach(id => {
                const element = document.getElementById(id);
                console.log(`3. Element ${id}:`, !!element, element?.textContent);
            });
            
            // Test 4: Force model status update
            console.log('4. Forcing model status update...');
            predictor.updateModelStatusDisplay();
            
            // Test 5: Check publisher analytics
            console.log('5. Publisher Analytics:', predictor.publisherAnalytics);
            
            console.log('========================');
            console.log('✅ Validation complete. Check logs above for issues.');
        }
        
        // Make test function globally available
        window.validateSystem = validateSystem;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Page loaded, initializing system...');
            
            // Set initial debug panel state (closed by default)
            const debugToggleBtn = document.getElementById('debug-toggle');
            debugToggleBtn.innerHTML = '<i class="fas fa-bug me-1"></i> Show Debug';
            window.debugPanelVisible = false;
            
            // Force update model status display after a brief delay to ensure DOM is ready
            setTimeout(() => {
                console.log('⏰ Forcing model status update...');
                predictor.updateModelStatusDisplay();
                
                // Set initial temporal weighting UI state
                setTimeout(() => {
                    updateTemporalWeightingUI();
                }, 50);
                
                // Test the system after initialization
                setTimeout(() => {
                    validateSystem();
                }, 500);
            }, 100);
        });
    </script>
</body>
</html>
